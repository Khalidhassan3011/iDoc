---
title: 47. Median of Two Sorted Arrays
description: Find the median of two sorted arrays of different sizes
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { TranslatedText, LanguageSwitcher } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

## <TranslatedText en="Problem Statement" bn="সমস্যার বিবৃতি" />

<TranslatedText
  en="Given two sorted arrays of different sizes, find the median of the two sorted arrays combined. The overall run time complexity should be O(log(min(m,n)))."
  bn="বিভিন্ন আকারের দুটি সর্ট করা অ্যারে দেওয়া হয়েছে, দুটি সর্ট করা অ্যারে একত্রিত করার পরে মিডিয়ান খুঁজুন। সামগ্রিক রান টাইম কমপ্লেক্সিটি O(log(min(m,n))) হওয়া উচিত।"
/>

## <TranslatedText en="What is Median?" bn="মিডিয়ান কী?" />

<TranslatedText
  en="The median is the middle value in an ordered list of numbers:"
  bn="মিডিয়ান হলো সংখ্যার একটি সাজানো তালিকার মধ্যম মান:"
/>

- **<TranslatedText en="For odd length" bn="বিষম দৈর্ঘ্যের জন্য" />**: <TranslatedText en="middle element" bn="মধ্যম এলিমেন্ট" />
- **<TranslatedText en="For even length" bn="জোড় দৈর্ঘ্যের জন্য" />**: <TranslatedText en="average of two middle elements" bn="দুটি মধ্যম এলিমেন্টের গড়" />

## <TranslatedText en="Examples" bn="উদাহরণসমূহ" />

### <TranslatedText en="Example 1" bn="উদাহরণ ১" />

```
Input: arr1 = [1, 3], arr2 = [2]
Output: 2.0
Explanation: Combined sorted: [1, 2, 3], median = 2
```

### <TranslatedText en="Example 2" bn="উদাহরণ ২" />

```
Input: arr1 = [1, 2], arr2 = [3, 4]
Output: 2.5
Explanation: Combined sorted: [1, 2, 3, 4], median = (2 + 3) / 2 = 2.5
```

### <TranslatedText en="Example 3" bn="উদাহরণ ৩" />

```
Input: arr1 = [1, 5, 9], arr2 = [2, 3, 6, 7]
Output: 5.0
Explanation: Combined sorted: [1, 2, 3, 5, 6, 7, 9], median = 5
```

## <TranslatedText en="Solution Approaches" bn="সমাধানের পদ্ধতিসমূহ" />

### <TranslatedText en="Approach 1: Merge and Find Median (Simple)" bn="পদ্ধতি ১: মার্জ করুন এবং মিডিয়ান খুঁজুন (সহজ)" />

<TranslatedText
  en="Merge both sorted arrays and find the median. This is the most intuitive approach."
  bn="উভয় সর্ট করা অ্যারে মার্জ করুন এবং মিডিয়ান খুঁজুন। এটি সবচেয়ে স্বজ্ঞাত পদ্ধতি।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(m + n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(m + n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

double findMedianMerge(const vector<int>& arr1, const vector<int>& arr2) {
    vector<int> merged;
    int i = 0, j = 0;

    // Merge two sorted arrays
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] <= arr2[j]) {
            merged.push_back(arr1[i++]);
        } else {
            merged.push_back(arr2[j++]);
        }
    }

    // Add remaining elements
    while (i < arr1.size()) {
        merged.push_back(arr1[i++]);
    }

    while (j < arr2.size()) {
        merged.push_back(arr2[j++]);
    }

    // Find median
    int n = merged.size();
    if (n % 2 == 0) {
        return (merged[n / 2 - 1] + merged[n / 2]) / 2.0;
    } else {
        return merged[n / 2];
    }
}

int main() {
    vector<int> arr1 = {1, 3};
    vector<int> arr2 = {2};
    cout << "Array 1: ";
    for (int x : arr1) cout << x << " ";
    cout << "\nArray 2: ";
    for (int x : arr2) cout << x << " ";
    cout << "\nMedian: " << findMedianMerge(arr1, arr2) << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def find_median_merge(arr1, arr2):
    """Merge and find median"""
    merged = []
    i, j = 0, 0

    # Merge two sorted arrays
    while i < len(arr1) and j < len(arr2):
        if arr1[i] <= arr2[j]:
            merged.append(arr1[i])
            i += 1
        else:
            merged.append(arr2[j])
            j += 1

    # Add remaining elements
    while i < len(arr1):
        merged.append(arr1[i])
        i += 1

    while j < len(arr2):
        merged.append(arr2[j])
        j += 1

    # Find median
    n = len(merged)
    if n % 2 == 0:
        return (merged[n // 2 - 1] + merged[n // 2]) / 2.0
    else:
        return float(merged[n // 2])

# Example usage
arr1 = [1, 3]
arr2 = [2]
print(f"Array 1: {arr1}")
print(f"Array 2: {arr2}")
print(f"Median: {find_median_merge(arr1, arr2)}")

arr3 = [1, 2]
arr4 = [3, 4]
print(f"\nArray 1: {arr3}")
print(f"Array 2: {arr4}")
print(f"Median: {find_median_merge(arr3, arr4)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function findMedianMerge(arr1, arr2) {
    let merged = [];
    let i = 0, j = 0;

    // Merge two sorted arrays
    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] <= arr2[j]) {
            merged.push(arr1[i++]);
        } else {
            merged.push(arr2[j++]);
        }
    }

    // Add remaining elements
    while (i < arr1.length) {
        merged.push(arr1[i++]);
    }

    while (j < arr2.length) {
        merged.push(arr2[j++]);
    }

    // Find median
    let n = merged.length;
    if (n % 2 === 0) {
        return (merged[Math.floor(n / 2) - 1] + merged[Math.floor(n / 2)]) / 2.0;
    } else {
        return merged[Math.floor(n / 2)];
    }
}

// Example usage
let arr1 = [1, 3];
let arr2 = [2];
console.log("Array 1:", arr1);
console.log("Array 2:", arr2);
console.log("Median:", findMedianMerge(arr1, arr2));

let arr3 = [1, 2];
let arr4 = [3, 4];
console.log("\nArray 1:", arr3);
console.log("Array 2:", arr4);
console.log("Median:", findMedianMerge(arr3, arr4));
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 2: Without Extra Space (Optimized)" bn="পদ্ধতি ২: অতিরিক্ত স্পেস ছাড়া (অপটিমাইজড)" />

<TranslatedText
  en="Find median without storing the entire merged array. We only track the middle elements as we iterate."
  bn="সম্পূর্ণ মার্জ করা অ্যারে সংরক্ষণ না করে মিডিয়ান খুঁজুন। আমরা ইটারেট করার সময় শুধুমাত্র মধ্যম এলিমেন্টগুলি ট্র্যাক করি।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(m + n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

double findMedianNoExtraSpace(const vector<int>& arr1, const vector<int>& arr2) {
    int m = arr1.size();
    int n = arr2.size();
    int total = m + n;

    int i = 0, j = 0, count = 0;
    int median1 = 0, median2 = 0;

    // We only need to find elements at positions total/2 and total/2-1
    while (count <= total / 2) {
        median1 = median2;

        if (i < m && (j >= n || arr1[i] <= arr2[j])) {
            median2 = arr1[i++];
        } else {
            median2 = arr2[j++];
        }

        count++;
    }

    if (total % 2 == 0) {
        return (median1 + median2) / 2.0;
    } else {
        return median2;
    }
}

int main() {
    vector<int> arr1 = {1, 3, 5};
    vector<int> arr2 = {2, 4, 6};
    cout << "Array 1: ";
    for (int x : arr1) cout << x << " ";
    cout << "\nArray 2: ";
    for (int x : arr2) cout << x << " ";
    cout << "\nMedian: " << findMedianNoExtraSpace(arr1, arr2) << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def find_median_no_extra_space(arr1, arr2):
    """Find median without extra space"""
    m, n = len(arr1), len(arr2)
    total = m + n

    i, j, count = 0, 0, 0
    median1, median2 = 0, 0

    # We only need to find elements at positions total/2 and total/2-1
    while count <= total // 2:
        median1 = median2

        if i < m and (j >= n or arr1[i] <= arr2[j]):
            median2 = arr1[i]
            i += 1
        else:
            median2 = arr2[j]
            j += 1

        count += 1

    if total % 2 == 0:
        return (median1 + median2) / 2.0
    else:
        return float(median2)

# Example usage
arr1 = [1, 3, 5]
arr2 = [2, 4, 6]
print(f"Array 1: {arr1}")
print(f"Array 2: {arr2}")
print(f"Median: {find_median_no_extra_space(arr1, arr2)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function findMedianNoExtraSpace(arr1, arr2) {
    let m = arr1.length;
    let n = arr2.length;
    let total = m + n;

    let i = 0, j = 0, count = 0;
    let median1 = 0, median2 = 0;

    // We only need to find elements at positions total/2 and total/2-1
    while (count <= Math.floor(total / 2)) {
        median1 = median2;

        if (i < m && (j >= n || arr1[i] <= arr2[j])) {
            median2 = arr1[i++];
        } else {
            median2 = arr2[j++];
        }

        count++;
    }

    if (total % 2 === 0) {
        return (median1 + median2) / 2.0;
    } else {
        return median2;
    }
}

// Example usage
let arr1 = [1, 3, 5];
let arr2 = [2, 4, 6];
console.log("Array 1:", arr1);
console.log("Array 2:", arr2);
console.log("Median:", findMedianNoExtraSpace(arr1, arr2));
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 3: Binary Search (Optimal)" bn="পদ্ধতি ৩: বাইনারি সার্চ (সর্বোত্তম)" />

<TranslatedText
  en="The most efficient approach using binary search on the smaller array. Achieves O(log(min(m,n))) time complexity."
  bn="ছোট অ্যারেতে বাইনারি সার্চ ব্যবহার করে সবচেয়ে কার্যকর পদ্ধতি। O(log(min(m,n))) সময় জটিলতা অর্জন করে।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(log(min(m, n)))
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<TranslatedText
  en="**Key Idea**: Partition both arrays such that left half contains exactly (m+n+1)/2 elements and max(left) ≤ min(right)."
  bn="**মূল ধারণা**: উভয় অ্যারে পার্টিশন করুন যাতে বাম অর্ধেক ঠিক (m+n+1)/2 এলিমেন্ট ধারণ করে এবং max(left) ≤ min(right)।"
/>

<Tabs items={['Python']} groupId="language">
  <Tab value="Python">
```python
def find_median_binary_search(arr1, arr2):
    """Binary search approach - O(log(min(m,n)))"""
    # Ensure arr1 is the smaller array
    if len(arr1) > len(arr2):
        return find_median_binary_search(arr2, arr1)

    m, n = len(arr1), len(arr2)
    left, right = 0, m

    while left <= right:
        # Partition arr1
        partition1 = (left + right) // 2
        # Partition arr2
        partition2 = (m + n + 1) // 2 - partition1

        # Handle edge cases
        maxLeft1 = float('-inf') if partition1 == 0 else arr1[partition1 - 1]
        minRight1 = float('inf') if partition1 == m else arr1[partition1]

        maxLeft2 = float('-inf') if partition2 == 0 else arr2[partition2 - 1]
        minRight2 = float('inf') if partition2 == n else arr2[partition2]

        # Check if we found the correct partition
        if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
            # Even total length
            if (m + n) % 2 == 0:
                return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2.0
            else:
                # Odd total length
                return float(max(maxLeft1, maxLeft2))
        elif maxLeft1 > minRight2:
            # Move towards left in arr1
            right = partition1 - 1
        else:
            # Move towards right in arr1
            left = partition1 + 1

    raise Exception('Input arrays are not sorted')

# Example usage
arr1 = [1, 3, 8, 9, 15]
arr2 = [7, 11, 18, 19, 21, 25]
print(f"Array 1: {arr1}")
print(f"Array 2: {arr2}")
print(f"Median (Binary Search): {find_median_binary_search(arr1, arr2)}")
```
  </Tab>
</Tabs>

## <TranslatedText en="Algorithm Walkthrough" bn="অ্যালগরিদম ওয়াকথ্রু" />

<TranslatedText
  en="Let's trace the merge approach for `[1, 3]` and `[2]`:"
  bn="চলুন `[1, 3]` এবং `[2]` এর জন্য মার্জ পদ্ধতি ট্রেস করি:"
/>

```
Array 1: [1, 3]
Array 2: [2]

Merge Process:
Step 1: Compare 1 vs 2 → 1 smaller → merged = [1]
Step 2: Compare 3 vs 2 → 2 smaller → merged = [1, 2]
Step 3: No more in arr2, add 3 → merged = [1, 2, 3]

Final merged: [1, 2, 3]
Length: 3 (odd)
Median position: 3 / 2 = 1
Median: merged[1] = 2
```

### <TranslatedText en="Even Length Example" bn="জোড় দৈর্ঘ্যের উদাহরণ" />

```
Array 1: [1, 2]
Array 2: [3, 4]

Final merged: [1, 2, 3, 4]
Length: 4 (even)
Median positions: index 1 and 2
Median: (2 + 3) / 2 = 2.5
```

## <TranslatedText en="Comparison of Approaches" bn="পদ্ধতিসমূহের তুলনা" />

| <TranslatedText en="Approach" bn="পদ্ধতি" /> | <TranslatedText en="Time" bn="সময়" /> | <TranslatedText en="Space" bn="স্থান" /> | <TranslatedText en="Pros" bn="সুবিধা" /> | <TranslatedText en="Cons" bn="অসুবিধা" /> |
|----------|------|-------|------|------|
| Merge Arrays | O(m+n) | O(m+n) | <TranslatedText en="Simple, easy to understand" bn="সহজ, বোঝা সহজ" /> | <TranslatedText en="Extra space" bn="অতিরিক্ত স্পেস" /> |
| No Extra Space | O(m+n) | O(1) | <TranslatedText en="Space efficient" bn="স্পেস সাশ্রয়ী" /> | <TranslatedText en="Still O(m+n) time" bn="এখনও O(m+n) সময়" /> |
| Binary Search | O(log(min(m,n))) | O(1) | <TranslatedText en="Optimal complexity" bn="সর্বোত্তম কমপ্লেক্সিটি" /> | <TranslatedText en="Complex logic" bn="জটিল লজিক" /> |

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

### 1. <TranslatedText en="Median Definition" bn="মিডিয়ান সংজ্ঞা" />

<TranslatedText
  en="For **odd** length, median is the middle element. For **even** length, median is the average of the two middle elements."
  bn="**বিষম** দৈর্ঘ্যের জন্য, মিডিয়ান মধ্যম এলিমেন্ট। **জোড়** দৈর্ঘ্যের জন্য, মিডিয়ান দুটি মধ্যম এলিমেন্টের গড়।"
/>

### 2. <TranslatedText en="Binary Search Insight" bn="বাইনারি সার্চ অন্তর্দৃষ্টি" />

<TranslatedText
  en="The key insight is partitioning: we want max(left half) ≤ min(right half) with exactly half the elements on the left."
  bn="মূল অন্তর্দৃষ্টি হলো পার্টিশনিং: আমরা চাই max(বাম অর্ধেক) ≤ min(ডান অর্ধেক) বামে ঠিক অর্ধেক এলিমেন্ট সহ।"
/>

### 3. <TranslatedText en="Optimization" bn="অপটিমাইজেশন" />

<TranslatedText
  en="Binary search on the **smaller array** reduces time complexity from O(m+n) to O(log(min(m,n)))."
  bn="**ছোট অ্যারেতে** বাইনারি সার্চ সময় জটিলতা O(m+n) থেকে O(log(min(m,n))) এ কমায়।"
/>

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

<TranslatedText
  en="1. **Start Simple**: Begin with merge approach, then optimize to binary search if asked"
  bn="১. **সহজ দিয়ে শুরু করুন**: মার্জ পদ্ধতি দিয়ে শুরু করুন, তারপর জিজ্ঞাসা করলে বাইনারি সার্চে অপটিমাইজ করুন"
/>

<TranslatedText
  en="2. **Handle Edge Cases**: Empty arrays, single elements, all from one array"
  bn="২. **এজ কেস হ্যান্ডেল করুন**: খালি অ্যারে, একক এলিমেন্ট, একটি অ্যারে থেকে সব"
/>

<TranslatedText
  en="3. **Odd vs Even**: Remember different formulas for odd and even total lengths"
  bn="৩. **বিষম বনাম জোড়**: বিষম এবং জোড় মোট দৈর্ঘ্যের জন্য বিভিন্ন সূত্র মনে রাখুন"
/>

<TranslatedText
  en="4. **Binary Search Logic**: Ensure smaller array is arr1 to minimize search space"
  bn="৪. **বাইনারি সার্চ লজিক**: সার্চ স্পেস কমাতে ছোট অ্যারে arr1 নিশ্চিত করুন"
/>

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Three Approaches:</strong> Merge (simple), No extra space (optimized), Binary search (optimal)</li>
        <li><strong>Optimal Complexity:</strong> O(log(min(m,n))) using binary search on smaller array</li>
        <li><strong>Partition Concept:</strong> Key to binary search is finding correct partition where max(left) ≤ min(right)</li>
        <li><strong>Practical Use:</strong> Statistics, data analysis, database optimization</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>তিনটি পদ্ধতি:</strong> মার্জ (সহজ), অতিরিক্ত স্পেস নেই (অপটিমাইজড), বাইনারি সার্চ (সর্বোত্তম)</li>
        <li><strong>সর্বোত্তম কমপ্লেক্সিটি:</strong> ছোট অ্যারেতে বাইনারি সার্চ ব্যবহার করে O(log(min(m,n)))</li>
        <li><strong>পার্টিশন ধারণা:</strong> বাইনারি সার্চের চাবিকাঠি হলো সঠিক পার্টিশন খুঁজে পাওয়া যেখানে max(বাম) ≤ min(ডান)</li>
        <li><strong>ব্যবহারিক ব্যবহার:</strong> পরিসংখ্যান, ডেটা বিশ্লেষণ, ডেটাবেস অপটিমাইজেশন</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Reference" bn="রেফারেন্স" />

[GeeksforGeeks - Median of Two Sorted Arrays](https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/)
