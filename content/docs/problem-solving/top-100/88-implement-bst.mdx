---
title: 88. Implement Binary Search Tree
description: Implement BST with insert, search, and delete operations
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="Implement Binary Search Tree" bn="বাইনারি সার্চ ট্রি বাস্তবায়ন করুন" />

<TranslatedText
  en="Implement a binary search tree with insert, search, and delete operations."
  bn="ইনসার্ট, সার্চ এবং ডিলিট অপারেশন সহ একটি বাইনারি সার্চ ট্রি বাস্তবায়ন করুন।"
/>

## <TranslatedText en="Solution" bn="সমাধান" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
using namespace std;

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class BST {
public:
    TreeNode* root;

    BST() : root(nullptr) {}

    TreeNode* insert(TreeNode* node, int val) {
        if (node == nullptr) {
            return new TreeNode(val);
        }

        if (val < node->val) {
            node->left = insert(node->left, val);
        } else if (val > node->val) {
            node->right = insert(node->right, val);
        }

        return node;
    }

    bool search(TreeNode* node, int val) {
        if (node == nullptr) return false;
        if (node->val == val) return true;

        if (val < node->val) {
            return search(node->left, val);
        } else {
            return search(node->right, val);
        }
    }

    TreeNode* findMin(TreeNode* node) {
        while (node->left != nullptr) {
            node = node->left;
        }
        return node;
    }

    TreeNode* deleteNode(TreeNode* node, int val) {
        if (node == nullptr) return nullptr;

        if (val < node->val) {
            node->left = deleteNode(node->left, val);
        } else if (val > node->val) {
            node->right = deleteNode(node->right, val);
        } else {
            // Node with one child or no child
            if (node->left == nullptr) {
                TreeNode* temp = node->right;
                delete node;
                return temp;
            } else if (node->right == nullptr) {
                TreeNode* temp = node->left;
                delete node;
                return temp;
            }

            // Node with two children
            TreeNode* temp = findMin(node->right);
            node->val = temp->val;
            node->right = deleteNode(node->right, temp->val);
        }

        return node;
    }

    void inorder(TreeNode* node) {
        if (node == nullptr) return;
        inorder(node->left);
        cout << node->val << " ";
        inorder(node->right);
    }
};

int main() {
    BST bst;
    bst.root = bst.insert(bst.root, 50);
    bst.insert(bst.root, 30);
    bst.insert(bst.root, 70);
    bst.insert(bst.root, 20);
    bst.insert(bst.root, 40);

    cout << "Inorder: ";
    bst.inorder(bst.root);
    cout << endl;

    cout << "Search 40: " << (bst.search(bst.root, 40) ? "Found" : "Not Found") << endl;

    bst.root = bst.deleteNode(bst.root, 30);
    cout << "After deleting 30: ";
    bst.inorder(bst.root);
    cout << endl;

    return 0;
}
```

**Output:**
```
Inorder: 20 30 40 50 70
Search 40: Found
After deleting 30: 20 40 50 70
```
  </Tab>
  <Tab value="Python">
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None

    def insert(self, node, val):
        if not node:
            return TreeNode(val)

        if val < node.val:
            node.left = self.insert(node.left, val)
        elif val > node.val:
            node.right = self.insert(node.right, val)

        return node

    def search(self, node, val):
        if not node:
            return False
        if node.val == val:
            return True

        if val < node.val:
            return self.search(node.left, val)
        else:
            return self.search(node.right, val)

    def find_min(self, node):
        while node.left:
            node = node.left
        return node

    def delete_node(self, node, val):
        if not node:
            return None

        if val < node.val:
            node.left = self.delete_node(node.left, val)
        elif val > node.val:
            node.right = self.delete_node(node.right, val)
        else:
            if not node.left:
                return node.right
            elif not node.right:
                return node.left

            temp = self.find_min(node.right)
            node.val = temp.val
            node.right = self.delete_node(node.right, temp.val)

        return node

    def inorder(self, node):
        if not node:
            return
        self.inorder(node.left)
        print(node.val, end=" ")
        self.inorder(node.right)

# Example
bst = BST()
bst.root = bst.insert(bst.root, 50)
bst.insert(bst.root, 30)
bst.insert(bst.root, 70)
bst.insert(bst.root, 20)
bst.insert(bst.root, 40)

print("Inorder:", end=" ")
bst.inorder(bst.root)
print()

print("Search 40:", "Found" if bst.search(bst.root, 40) else "Not Found")

bst.root = bst.delete_node(bst.root, 30)
print("After deleting 30:", end=" ")
bst.inorder(bst.root)
print()
```

**Output:**
```
Inorder: 20 30 40 50 70
Search 40: Found
After deleting 30: 20 40 50 70
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class TreeNode {
    constructor(val, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class BST {
    constructor() {
        this.root = null;
    }

    insert(node, val) {
        if (!node) {
            return new TreeNode(val);
        }

        if (val < node.val) {
            node.left = this.insert(node.left, val);
        } else if (val > node.val) {
            node.right = this.insert(node.right, val);
        }

        return node;
    }

    search(node, val) {
        if (!node) return false;
        if (node.val === val) return true;

        if (val < node.val) {
            return this.search(node.left, val);
        } else {
            return this.search(node.right, val);
        }
    }

    findMin(node) {
        while (node.left) {
            node = node.left;
        }
        return node;
    }

    deleteNode(node, val) {
        if (!node) return null;

        if (val < node.val) {
            node.left = this.deleteNode(node.left, val);
        } else if (val > node.val) {
            node.right = this.deleteNode(node.right, val);
        } else {
            if (!node.left) return node.right;
            if (!node.right) return node.left;

            const temp = this.findMin(node.right);
            node.val = temp.val;
            node.right = this.deleteNode(node.right, temp.val);
        }

        return node;
    }

    inorder(node) {
        if (!node) return;
        this.inorder(node.left);
        process.stdout.write(node.val + " ");
        this.inorder(node.right);
    }
}

// Example
const bst = new BST();
bst.root = bst.insert(bst.root, 50);
bst.insert(bst.root, 30);
bst.insert(bst.root, 70);
bst.insert(bst.root, 20);
bst.insert(bst.root, 40);

process.stdout.write("Inorder: ");
bst.inorder(bst.root);
console.log();

console.log("Search 40:", bst.search(bst.root, 40) ? "Found" : "Not Found");

bst.root = bst.deleteNode(bst.root, 30);
process.stdout.write("After deleting 30: ");
bst.inorder(bst.root);
console.log();
```

**Output:**
```
Inorder: 20 30 40 50 70
Search 40: Found
After deleting 30: 20 40 50 70
```
  </Tab>
</Tabs>

<TranslatedText
  en={
    <>
      <p><strong>Time Complexity:</strong> O(h) for all operations (h = height)</p>
      <p><strong>Space Complexity:</strong> O(h) for recursion</p>
    </>
  }
  bn={
    <>
      <p><strong>সময় জটিলতা:</strong> O(h) সব অপারেশনের জন্য (h = উচ্চতা)</p>
      <p><strong>স্থান জটিলতা:</strong> O(h) রিকার্শনের জন্য</p>
    </>
  }
/>
