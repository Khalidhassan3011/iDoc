---
title: 46. Binary Search in Array
description: How to perform binary search in a sorted array
---

## Problem Statement

Implement binary search algorithm to find an element in a sorted array. Binary search is an efficient algorithm that works by repeatedly dividing the search interval in half.

## Algorithm Overview

Binary search works on **sorted arrays** only:
1. Compare target with middle element
2. If target equals middle, return index
3. If target is less, search left half
4. If target is greater, search right half
5. Repeat until found or search space is empty

## Examples

### Example 1
```
Input: arr = [1, 3, 5, 7, 9, 11, 13], target = 7
Output: 3 (index of 7)
```

### Example 2
```
Input: arr = [2, 4, 6, 8, 10], target = 5
Output: -1 (not found)
```

### Example 3
```
Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 1
Output: 0
```

## Solution

### Approach 1: Iterative Binary Search (Recommended)

The standard iterative implementation.

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

```dart
int binarySearch(List<int> arr, int target) {
  int left = 0;
  int right = arr.length - 1;

  while (left <= right) {
    // Calculate middle index (avoids overflow)
    int mid = left + (right - left) ~/ 2;

    if (arr[mid] == target) {
      return mid; // Found
    } else if (arr[mid] < target) {
      left = mid + 1; // Search right half
    } else {
      right = mid - 1; // Search left half
    }
  }

  return -1; // Not found
}

void main() {
  List<int> arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];

  print('Array: $arr\n');

  List<int> targets = [7, 5, 20, 1, 19];
  for (int target in targets) {
    int index = binarySearch(arr, target);
    if (index != -1) {
      print('Found $target at index $index');
    } else {
      print('$target not found in array');
    }
  }
}
```

### Approach 2: Recursive Binary Search

Elegant recursive implementation.

**Time Complexity:** O(log n)
**Space Complexity:** O(log n) due to recursion stack

```dart
int binarySearchRecursive(List<int> arr, int target, int left, int right) {
  if (left > right) {
    return -1; // Base case: not found
  }

  int mid = left + (right - left) ~/ 2;

  if (arr[mid] == target) {
    return mid; // Found
  } else if (arr[mid] < target) {
    return binarySearchRecursive(arr, target, mid + 1, right); // Search right
  } else {
    return binarySearchRecursive(arr, target, left, mid - 1); // Search left
  }
}

void main() {
  List<int> arr = [1, 3, 5, 7, 9, 11, 13];

  print('Array: $arr');

  int target = 7;
  int index = binarySearchRecursive(arr, target, 0, arr.length - 1);

  if (index != -1) {
    print('Found $target at index $index');
  } else {
    print('$target not found');
  }
}
```

### Approach 3: Binary Search with First Occurrence

Find the first occurrence of a target (useful for duplicates).

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

```dart
int binarySearchFirst(List<int> arr, int target) {
  int left = 0;
  int right = arr.length - 1;
  int result = -1;

  while (left <= right) {
    int mid = left + (right - left) ~/ 2;

    if (arr[mid] == target) {
      result = mid;
      right = mid - 1; // Continue searching in left half
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return result;
}

void main() {
  List<int> arr = [1, 2, 2, 2, 3, 4, 5];
  print('Array: $arr');

  int target = 2;
  int index = binarySearchFirst(arr, target);
  print('First occurrence of $target at index $index');
}
```

### Approach 4: Binary Search with Last Occurrence

Find the last occurrence of a target.

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

```dart
int binarySearchLast(List<int> arr, int target) {
  int left = 0;
  int right = arr.length - 1;
  int result = -1;

  while (left <= right) {
    int mid = left + (right - left) ~/ 2;

    if (arr[mid] == target) {
      result = mid;
      left = mid + 1; // Continue searching in right half
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return result;
}

void main() {
  List<int> arr = [1, 2, 2, 2, 3, 4, 5];
  print('Array: $arr');

  int target = 2;
  int index = binarySearchLast(arr, target);
  print('Last occurrence of $target at index $index');
}
```

### Approach 5: Binary Search for Insertion Position

Find the position where target should be inserted to maintain sorted order.

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

```dart
int binarySearchInsertPosition(List<int> arr, int target) {
  int left = 0;
  int right = arr.length - 1;

  while (left <= right) {
    int mid = left + (right - left) ~/ 2;

    if (arr[mid] == target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return left; // Position to insert
}

void main() {
  List<int> arr = [1, 3, 5, 7, 9];
  print('Array: $arr');

  List<int> targets = [4, 0, 10];
  for (int target in targets) {
    int pos = binarySearchInsertPosition(arr, target);
    print('Insert $target at position $pos');
  }
}
```

### Approach 6: Binary Search with Custom Comparator

Generic binary search that works with any comparable type.

**Time Complexity:** O(log n)
**Space Complexity:** O(1)

```dart
int binarySearchGeneric<T>(
  List<T> arr,
  T target,
  int Function(T a, T b) compare,
) {
  int left = 0;
  int right = arr.length - 1;

  while (left <= right) {
    int mid = left + (right - left) ~/ 2;
    int cmp = compare(arr[mid], target);

    if (cmp == 0) {
      return mid;
    } else if (cmp < 0) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

void main() {
  // Integer search
  List<int> numbers = [1, 3, 5, 7, 9];
  int numIndex = binarySearchGeneric(
    numbers,
    5,
    (a, b) => a.compareTo(b),
  );
  print('Found 5 at index $numIndex');

  // String search
  List<String> words = ['apple', 'banana', 'cherry', 'date'];
  int strIndex = binarySearchGeneric(
    words,
    'cherry',
    (a, b) => a.compareTo(b),
  );
  print('Found cherry at index $strIndex');
}
```

### Approach 7: Using Dart's Built-in Methods

Dart doesn't have built-in binary search, but here's how to implement it cleanly.

```dart
extension BinarySearchExtension on List<int> {
  int binarySearch(int target) {
    int left = 0;
    int right = length - 1;

    while (left <= right) {
      int mid = left + (right - left) ~/ 2;

      if (this[mid] == target) {
        return mid;
      } else if (this[mid] < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    return -1;
  }
}

void main() {
  List<int> arr = [1, 3, 5, 7, 9, 11, 13];
  print('Array: $arr');

  int index = arr.binarySearch(7);
  print('Found 7 at index $index');
}
```

## Visualization

Searching for 7 in [1, 3, 5, 7, 9, 11, 13]:

```
Step 1:
[1, 3, 5, 7, 9, 11, 13]
 L        M          R
Compare: 7 vs 7 → Found! Return index 3

Example with 9:
Step 1:
[1, 3, 5, 7, 9, 11, 13]
 L        M          R
Compare: 9 vs 7 → 9 > 7, search right

Step 2:
[1, 3, 5, 7, 9, 11, 13]
             L  M   R
Compare: 9 vs 11 → 9 < 11, search left

Step 3:
[1, 3, 5, 7, 9, 11, 13]
             L
             M
             R
Compare: 9 vs 9 → Found! Return index 4
```

## Key Points

1. **Sorted Array Required**: Binary search only works on sorted arrays
2. **O(log n) Complexity**: Very efficient for large datasets
3. **Divide and Conquer**: Repeatedly halves the search space
4. **Iterative vs Recursive**: Iterative is preferred (no stack overhead)
5. **Overflow Prevention**: Use `left + (right - left) / 2` instead of `(left + right) / 2`

## Common Variations

### 1. Count Occurrences
```dart
int countOccurrences(List<int> arr, int target) {
  int first = binarySearchFirst(arr, target);
  if (first == -1) return 0;

  int last = binarySearchLast(arr, target);
  return last - first + 1;
}
```

### 2. Find Closest Element
```dart
int findClosest(List<int> arr, int target) {
  int left = 0;
  int right = arr.length - 1;

  if (target <= arr[left]) return left;
  if (target >= arr[right]) return right;

  while (left < right) {
    int mid = left + (right - left) ~/ 2;

    if (arr[mid] == target) return mid;

    if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }

  // Check which is closer
  if (left > 0 && (target - arr[left - 1]).abs() < (arr[left] - target).abs()) {
    return left - 1;
  }

  return left;
}
```

## Comparison with Linear Search

| Aspect | Binary Search | Linear Search |
|--------|---------------|---------------|
| Time Complexity | O(log n) | O(n) |
| Requires Sorted | Yes | No |
| Best For | Large arrays | Small arrays |
| Implementation | More complex | Simple |

## Common Pitfalls

- Forgetting array must be sorted
- Using `(left + right) / 2` which can overflow
- Using `<` instead of `<=` in while condition
- Not handling empty array case
- Off-by-one errors in boundary updates

## Test Cases

```dart
void testBinarySearch() {
  // Test 1: Element exists
  assert(binarySearch([1, 3, 5, 7, 9], 5) == 2);

  // Test 2: Element doesn't exist
  assert(binarySearch([1, 3, 5, 7, 9], 4) == -1);

  // Test 3: First element
  assert(binarySearch([1, 3, 5, 7, 9], 1) == 0);

  // Test 4: Last element
  assert(binarySearch([1, 3, 5, 7, 9], 9) == 4);

  // Test 5: Single element (found)
  assert(binarySearch([5], 5) == 0);

  // Test 6: Single element (not found)
  assert(binarySearch([5], 3) == -1);

  // Test 7: Empty array
  assert(binarySearch([], 5) == -1);

  // Test 8: Large array
  List<int> large = List.generate(1000, (i) => i * 2);
  assert(binarySearch(large, 500) == 250);

  print('All tests passed!');
}
```

## Performance

```dart
import 'dart:math';

void benchmark() {
  List<int> sizes = [100, 1000, 10000, 100000];

  for (int size in sizes) {
    List<int> arr = List.generate(size, (i) => i);
    int target = Random().nextInt(size);

    Stopwatch sw = Stopwatch()..start();
    binarySearch(arr, target);
    sw.stop();

    print('Size: $size, Time: ${sw.elapsedMicroseconds} μs');
  }
}
```

## Applications

- Dictionary lookups
- Database indexing
- Finding roots of equations
- Game AI (decision trees)
- Resource allocation
- Finding boundaries in data

## Reference

[JavaRevisited - Binary Search Implementation](http://javarevisited.blogspot.sg/2015/10/how-to-implement-binary-search-tree-in-java-example.html#axzz4wnEtnNB3)
