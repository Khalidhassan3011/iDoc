---
title: 46. Binary Search in Array
description: How to perform binary search in a sorted array
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { TranslatedText, LanguageSwitcher } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

## <TranslatedText en="Problem Statement" bn="সমস্যার বিবৃতি" />

<TranslatedText
  en="Implement binary search algorithm to find an element in a sorted array. Binary search is an efficient algorithm that works by repeatedly dividing the search interval in half."
  bn="একটি সর্ট করা অ্যারেতে একটি এলিমেন্ট খুঁজে পেতে বাইনারি সার্চ অ্যালগরিদম বাস্তবায়ন করুন। বাইনারি সার্চ একটি কার্যকর অ্যালগরিদম যা বারবার সার্চ ইন্টারভাল অর্ধেক ভাগ করে কাজ করে।"
/>

## <TranslatedText en="Algorithm Overview" bn="অ্যালগরিদম সংক্ষিপ্ত বিবরণ" />

<TranslatedText
  en="Binary search works on **sorted arrays** only:"
  bn="বাইনারি সার্চ শুধুমাত্র **সর্ট করা অ্যারেতে** কাজ করে:"
/>

<TranslatedText
  en="1. Compare target with middle element"
  bn="১. টার্গেটকে মধ্যম এলিমেন্টের সাথে তুলনা করুন"
/>

<TranslatedText
  en="2. If target equals middle, return index"
  bn="২. যদি টার্গেট মধ্যমের সমান হয়, ইনডেক্স রিটার্ন করুন"
/>

<TranslatedText
  en="3. If target is less, search left half"
  bn="৩. যদি টার্গেট কম হয়, বাম অর্ধেক সার্চ করুন"
/>

<TranslatedText
  en="4. If target is greater, search right half"
  bn="৪. যদি টার্গেট বেশি হয়, ডান অর্ধেক সার্চ করুন"
/>

<TranslatedText
  en="5. Repeat until found or search space is empty"
  bn="৫. খুঁজে পাওয়া বা সার্চ স্পেস খালি না হওয়া পর্যন্ত পুনরাবৃত্তি করুন"
/>

## <TranslatedText en="Examples" bn="উদাহরণসমূহ" />

### <TranslatedText en="Example 1" bn="উদাহরণ ১" />

```
Input: arr = [1, 3, 5, 7, 9, 11, 13], target = 7
Output: 3 (index of 7)
```

### <TranslatedText en="Example 2" bn="উদাহরণ ২" />

```
Input: arr = [2, 4, 6, 8, 10], target = 5
Output: -1 (not found)
```

### <TranslatedText en="Example 3" bn="উদাহরণ ৩" />

```
Input: arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], target = 1
Output: 0
```

## <TranslatedText en="Solution Approaches" bn="সমাধানের পদ্ধতিসমূহ" />

### <TranslatedText en="Approach 1: Iterative Binary Search (Recommended)" bn="পদ্ধতি ১: ইটারেটিভ বাইনারি সার্চ (প্রস্তাবিত)" />

<TranslatedText
  en="The standard iterative implementation. This is the most efficient approach with O(1) space complexity."
  bn="স্ট্যান্ডার্ড ইটারেটিভ বাস্তবায়ন। এটি O(1) স্পেস কমপ্লেক্সিটি সহ সবচেয়ে কার্যকর পদ্ধতি।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(log n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

int binarySearch(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        // Calculate middle index (avoids overflow)
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid; // Found
        } else if (arr[mid] < target) {
            left = mid + 1; // Search right half
        } else {
            right = mid - 1; // Search left half
        }
    }

    return -1; // Not found
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    cout << "Array: ";
    for (int x : arr) cout << x << " ";
    cout << "\n\n";

    vector<int> targets = {7, 5, 20, 1, 19};
    for (int target : targets) {
        int index = binarySearch(arr, target);
        if (index != -1) {
            cout << "Found " << target << " at index " << index << endl;
        } else {
            cout << target << " not found in array" << endl;
        }
    }

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def binary_search(arr, target):
    """Iterative binary search"""
    left = 0
    right = len(arr) - 1

    while left <= right:
        # Calculate middle index (avoids overflow)
        mid = left + (right - left) // 2

        if arr[mid] == target:
            return mid  # Found
        elif arr[mid] < target:
            left = mid + 1  # Search right half
        else:
            right = mid - 1  # Search left half

    return -1  # Not found

# Example usage
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
print(f"Array: {arr}\n")

targets = [7, 5, 20, 1, 19]
for target in targets:
    index = binary_search(arr, target)
    if index != -1:
        print(f"Found {target} at index {index}")
    else:
        print(f"{target} not found in array")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        // Calculate middle index (avoids overflow)
        let mid = left + Math.floor((right - left) / 2);

        if (arr[mid] === target) {
            return mid; // Found
        } else if (arr[mid] < target) {
            left = mid + 1; // Search right half
        } else {
            right = mid - 1; // Search left half
        }
    }

    return -1; // Not found
}

// Example usage
let arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
console.log("Array:", arr, "\n");

let targets = [7, 5, 20, 1, 19];
for (let target of targets) {
    let index = binarySearch(arr, target);
    if (index !== -1) {
        console.log(`Found ${target} at index ${index}`);
    } else {
        console.log(`${target} not found in array`);
    }
}
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 2: Recursive Binary Search" bn="পদ্ধতি ২: রিকার্সিভ বাইনারি সার্চ" />

<TranslatedText
  en="Elegant recursive implementation. Uses recursion stack, so space complexity is O(log n)."
  bn="মার্জিত রিকার্সিভ বাস্তবায়ন। রিকার্শন স্ট্যাক ব্যবহার করে, তাই স্পেস কমপ্লেক্সিটি O(log n)।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(log n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(log n) <TranslatedText en="due to recursion stack" bn="রিকার্শন স্ট্যাকের কারণে" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

int binarySearchRecursive(const vector<int>& arr, int target, int left, int right) {
    if (left > right) {
        return -1; // Base case: not found
    }

    int mid = left + (right - left) / 2;

    if (arr[mid] == target) {
        return mid; // Found
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right); // Search right
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1); // Search left
    }
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13};
    cout << "Array: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    int target = 7;
    int index = binarySearchRecursive(arr, target, 0, arr.size() - 1);

    if (index != -1) {
        cout << "Found " << target << " at index " << index << endl;
    } else {
        cout << target << " not found" << endl;
    }

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def binary_search_recursive(arr, target, left, right):
    """Recursive binary search"""
    if left > right:
        return -1  # Base case: not found

    mid = left + (right - left) // 2

    if arr[mid] == target:
        return mid  # Found
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)  # Search right
    else:
        return binary_search_recursive(arr, target, left, mid - 1)  # Search left

# Example usage
arr = [1, 3, 5, 7, 9, 11, 13]
print(f"Array: {arr}")

target = 7
index = binary_search_recursive(arr, target, 0, len(arr) - 1)

if index != -1:
    print(f"Found {target} at index {index}")
else:
    print(f"{target} not found")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function binarySearchRecursive(arr, target, left, right) {
    if (left > right) {
        return -1; // Base case: not found
    }

    let mid = left + Math.floor((right - left) / 2);

    if (arr[mid] === target) {
        return mid; // Found
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right); // Search right
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1); // Search left
    }
}

// Example usage
let arr = [1, 3, 5, 7, 9, 11, 13];
console.log("Array:", arr);

let target = 7;
let index = binarySearchRecursive(arr, target, 0, arr.length - 1);

if (index !== -1) {
    console.log(`Found ${target} at index ${index}`);
} else {
    console.log(`${target} not found`);
}
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 3: First Occurrence (For Duplicates)" bn="পদ্ধতি ৩: প্রথম ঘটনা (ডুপ্লিকেটের জন্য)" />

<TranslatedText
  en="Find the first occurrence of a target. Useful when array contains duplicates and you want the leftmost match."
  bn="টার্গেটের প্রথম ঘটনা খুঁজুন। যখন অ্যারেতে ডুপ্লিকেট থাকে এবং আপনি সবচেয়ে বাম ম্যাচ চান তখন উপযোগী।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(log n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

int binarySearchFirst(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    int result = -1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            result = mid;
            right = mid - 1; // Continue searching in left half
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

int main() {
    vector<int> arr = {1, 2, 2, 2, 3, 4, 5};
    cout << "Array: ";
    for (int x : arr) cout << x << " ";
    cout << endl;

    int target = 2;
    int index = binarySearchFirst(arr, target);
    cout << "First occurrence of " << target << " at index " << index << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def binary_search_first(arr, target):
    """Find first occurrence of target"""
    left = 0
    right = len(arr) - 1
    result = -1

    while left <= right:
        mid = left + (right - left) // 2

        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching in left half
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Example usage
arr = [1, 2, 2, 2, 3, 4, 5]
print(f"Array: {arr}")

target = 2
index = binary_search_first(arr, target)
print(f"First occurrence of {target} at index {index}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function binarySearchFirst(arr, target) {
    let left = 0;
    let right = arr.length - 1;
    let result = -1;

    while (left <= right) {
        let mid = left + Math.floor((right - left) / 2);

        if (arr[mid] === target) {
            result = mid;
            right = mid - 1; // Continue searching in left half
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return result;
}

// Example usage
let arr = [1, 2, 2, 2, 3, 4, 5];
console.log("Array:", arr);

let target = 2;
let index = binarySearchFirst(arr, target);
console.log(`First occurrence of ${target} at index ${index}`);
```
  </Tab>
</Tabs>

## <TranslatedText en="Algorithm Walkthrough" bn="অ্যালগরিদম ওয়াকথ্রু" />

<TranslatedText
  en="Let's trace binary search for target = 9 in array `[1, 3, 5, 7, 9, 11, 13]`:"
  bn="চলুন অ্যারে `[1, 3, 5, 7, 9, 11, 13]`-এ target = 9 এর জন্য বাইনারি সার্চ ট্রেস করি:"
/>

```
Array: [1, 3, 5, 7, 9, 11, 13]
Index:  0  1  2  3  4   5   6

Step 1:
  left = 0, right = 6
  mid = 0 + (6 - 0) / 2 = 3
  arr[3] = 7
  Compare: 9 vs 7 → 9 > 7
  Search right half → left = 4

Step 2:
  left = 4, right = 6
  mid = 4 + (6 - 4) / 2 = 5
  arr[5] = 11
  Compare: 9 vs 11 → 9 < 11
  Search left half → right = 4

Step 3:
  left = 4, right = 4
  mid = 4 + (4 - 4) / 2 = 4
  arr[4] = 9
  Compare: 9 vs 9 → Match! ✓
  Return index 4

Total comparisons: 3 (log₂ 7 ≈ 2.8)
```

## <TranslatedText en="Comparison with Linear Search" bn="লিনিয়ার সার্চের সাথে তুলনা" />

| <TranslatedText en="Aspect" bn="দিক" /> | <TranslatedText en="Binary Search" bn="বাইনারি সার্চ" /> | <TranslatedText en="Linear Search" bn="লিনিয়ার সার্চ" /> |
|--------|---------------|---------------|
| **<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />** | O(log n) | O(n) |
| **<TranslatedText en="Requires Sorted" bn="সর্ট করা প্রয়োজন" />** | <TranslatedText en="Yes" bn="হ্যাঁ" /> | <TranslatedText en="No" bn="না" /> |
| **<TranslatedText en="Best For" bn="সেরা জন্য" />** | <TranslatedText en="Large arrays" bn="বড় অ্যারে" /> | <TranslatedText en="Small arrays" bn="ছোট অ্যারে" /> |
| **<TranslatedText en="Implementation" bn="বাস্তবায়ন" />** | <TranslatedText en="More complex" bn="আরো জটিল" /> | <TranslatedText en="Simple" bn="সহজ" /> |

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

### 1. <TranslatedText en="Sorted Array Required" bn="সর্ট করা অ্যারে প্রয়োজন" />

<TranslatedText
  en="Binary search **only works on sorted arrays**. If the array is unsorted, you must either sort it first (O(n log n)) or use linear search (O(n))."
  bn="বাইনারি সার্চ **শুধুমাত্র সর্ট করা অ্যারেতে কাজ করে**। যদি অ্যারে আনসর্টেড হয়, আপনাকে হয় প্রথমে সর্ট করতে হবে (O(n log n)) অথবা লিনিয়ার সার্চ ব্যবহার করতে হবে (O(n))।"
/>

### 2. <TranslatedText en="Logarithmic Time Complexity" bn="লগারিদমিক সময় জটিলতা" />

<TranslatedText
  en="Binary search achieves O(log n) by **halving the search space** in each iteration. For an array of 1 million elements, it takes only ~20 comparisons!"
  bn="বাইনারি সার্চ প্রতিটি ইটারেশনে **সার্চ স্পেস অর্ধেক করে** O(log n) অর্জন করে। ১ মিলিয়ন এলিমেন্টের একটি অ্যারের জন্য, এটি শুধুমাত্র ~২০ তুলনা নেয়!"
/>

### 3. <TranslatedText en="Overflow Prevention" bn="ওভারফ্লো প্রতিরোধ" />

<TranslatedText
  en="Always use `left + (right - left) / 2` instead of `(left + right) / 2` to calculate mid. The latter can overflow when left and right are large integers."
  bn="মিড গণনা করতে `(left + right) / 2` এর পরিবর্তে সর্বদা `left + (right - left) / 2` ব্যবহার করুন। যখন left এবং right বড় ইন্টিজার হয় তখন পরেরটি ওভারফ্লো হতে পারে।"
/>

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

<TranslatedText
  en="1. **Check if Sorted**: Always verify the array is sorted before applying binary search"
  bn="১. **সর্ট করা চেক করুন**: বাইনারি সার্চ প্রয়োগ করার আগে সর্বদা যাচাই করুন অ্যারে সর্ট করা আছে কিনা"
/>

<TranslatedText
  en="2. **Boundary Conditions**: Pay attention to `<=` vs `<` in while loop and boundary updates"
  bn="২. **সীমানা শর্ত**: while লুপে `<=` বনাম `<` এবং সীমানা আপডেটে মনোযোগ দিন"
/>

<TranslatedText
  en="3. **Overflow Safety**: Use the overflow-safe mid calculation method"
  bn="৩. **ওভারফ্লো নিরাপত্তা**: ওভারফ্লো-নিরাপদ মিড গণনা পদ্ধতি ব্যবহার করুন"
/>

<TranslatedText
  en="4. **Variations**: Know first/last occurrence variants for duplicate handling"
  bn="৪. **বৈচিত্র্য**: ডুপ্লিকেট হ্যান্ডলিংয়ের জন্য প্রথম/শেষ ঘটনা বৈচিত্র্য জানুন"
/>

<TranslatedText
  en="5. **Complexity Analysis**: Explain why it's O(log n) - search space halves each time"
  bn="৫. **কমপ্লেক্সিটি বিশ্লেষণ**: ব্যাখ্যা করুন কেন এটি O(log n) - প্রতিবার সার্চ স্পেস অর্ধেক হয়"
/>

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>O(log n) Time:</strong> Binary search is very efficient for large sorted arrays</li>
        <li><strong>Sorted Requirement:</strong> Only works on sorted data - crucial constraint</li>
        <li><strong>Divide and Conquer:</strong> Repeatedly halves search space until target found or space empty</li>
        <li><strong>Iterative Preferred:</strong> Iterative approach is better than recursive (no stack overhead)</li>
        <li><strong>Many Variants:</strong> First/last occurrence, insertion position, closest element, etc.</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>O(log n) সময়:</strong> বাইনারি সার্চ বড় সর্ট করা অ্যারের জন্য খুবই কার্যকর</li>
        <li><strong>সর্ট করা প্রয়োজনীয়তা:</strong> শুধুমাত্র সর্ট করা ডেটাতে কাজ করে - গুরুত্বপূর্ণ সীমাবদ্ধতা</li>
        <li><strong>ভাগ করো এবং জয় করো:</strong> টার্গেট পাওয়া বা স্পেস খালি না হওয়া পর্যন্ত বারবার সার্চ স্পেস অর্ধেক করে</li>
        <li><strong>ইটারেটিভ পছন্দসই:</strong> ইটারেটিভ পদ্ধতি রিকার্সিভের চেয়ে ভালো (কোনো স্ট্যাক ওভারহেড নেই)</li>
        <li><strong>অনেক বৈচিত্র্য:</strong> প্রথম/শেষ ঘটনা, সন্নিবেশ অবস্থান, নিকটতম এলিমেন্ট, ইত্যাদি</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Applications" bn="প্রয়োগসমূহ" />

- <TranslatedText en="Dictionary lookups" bn="ডিকশনারি লুকআপ" />
- <TranslatedText en="Database indexing" bn="ডেটাবেস ইনডেক্সিং" />
- <TranslatedText en="Finding roots of equations" bn="সমীকরণের মূল খোঁজা" />
- <TranslatedText en="Game AI (decision trees)" bn="গেম AI (ডিসিশন ট্রি)" />
- <TranslatedText en="Resource allocation" bn="রিসোর্স বরাদ্দ" />

## <TranslatedText en="Reference" bn="রেফারেন্স" />

[JavaRevisited - Binary Search Implementation](http://javarevisited.blogspot.sg/2015/10/how-to-implement-binary-search-tree-in-java-example.html#axzz4wnEtnNB3)
