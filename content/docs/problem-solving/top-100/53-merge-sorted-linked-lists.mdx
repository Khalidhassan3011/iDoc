---
title: 53. Merge Two Sorted Linked Lists
description: How to merge two sorted linked lists into one sorted linked list
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { TranslatedText, LanguageSwitcher } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

## <TranslatedText en="Problem Statement" bn="সমস্যা বিবৃতি" />

<TranslatedText
  en="Given two sorted linked lists, merge them into a single sorted linked list. The new list should be made by splicing together the nodes of the input lists."
  bn="দুটি সাজানো লিঙ্কড লিস্ট দেওয়া হয়েছে, তাদের একটি একক সাজানো লিঙ্কড লিস্টে মার্জ করুন। নতুন লিস্টটি ইনপুট লিস্টের নোডগুলি একসাথে সংযুক্ত করে তৈরি করতে হবে।"
/>

## <TranslatedText en="Examples" bn="উদাহরণসমূহ" />

### <TranslatedText en="Example 1" bn="উদাহরণ ১" />
```
Input:
List 1: 1 -> 3 -> 5
List 2: 2 -> 4 -> 6
Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

### <TranslatedText en="Example 2" bn="উদাহরণ ২" />
```
Input:
List 1: 1 -> 2 -> 4
List 2: 1 -> 3 -> 4
Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4
```

### <TranslatedText en="Example 3" bn="উদাহরণ ৩" />
```
Input:
List 1: (empty)
List 2: 1 -> 2
Output: 1 -> 2
```

## <TranslatedText en="Solution Approaches" bn="সমাধানের পদ্ধতিসমূহ" />

### <TranslatedText en="Approach 1: Iterative with Dummy Node (Optimal)" bn="পদ্ধতি ১: ডামি নোড সহ ইটারেটিভ (সর্বোত্তম)" />

<TranslatedText
  en="Merge lists iteratively using a dummy node to simplify edge case handling."
  bn="এজ কেস হ্যান্ডলিং সহজ করতে ডামি নোড ব্যবহার করে লিস্টগুলি ইটারেটিভভাবে মার্জ করুন।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(m + n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<Tabs groupId="language" items={['c++', 'python', 'javascript']}>
  <Tab value="c++">
```cpp
#include <iostream>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    // Create dummy node
    ListNode dummy(0);
    ListNode* current = &dummy;

    // Merge while both lists have nodes
    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val <= l2->val) {
            current->next = l1;
            l1 = l1->next;
        } else {
            current->next = l2;
            l2 = l2->next;
        }
        current = current->next;
    }

    // Attach remaining nodes
    current->next = (l1 != nullptr) ? l1 : l2;

    return dummy.next; // Skip dummy node
}

void printList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        cout << current->val << " -> ";
        current = current->next;
    }
    cout << "null" << endl;
}

int main() {
    // List 1: 1 -> 3 -> 5
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(3);
    l1->next->next = new ListNode(5);

    // List 2: 2 -> 4 -> 6
    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(4);
    l2->next->next = new ListNode(6);

    cout << "List 1: ";
    printList(l1);

    cout << "List 2: ";
    printList(l2);

    ListNode* merged = mergeTwoLists(l1, l2);

    cout << "Merged list: ";
    printList(merged);

    return 0;
}
```
  </Tab>
  <Tab value="python">
```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def merge_two_lists(l1, l2):
    """Merge two sorted linked lists iteratively"""
    # Create dummy node
    dummy = ListNode(0)
    current = dummy

    # Merge while both lists have nodes
    while l1 is not None and l2 is not None:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    # Attach remaining nodes
    current.next = l1 if l1 is not None else l2

    return dummy.next  # Skip dummy node

def print_list(head):
    current = head
    while current:
        print(current.val, end=" -> ")
        current = current.next
    print("null")

# Example usage
if __name__ == "__main__":
    # List 1: 1 -> 3 -> 5
    l1 = ListNode(1)
    l1.next = ListNode(3)
    l1.next.next = ListNode(5)

    # List 2: 2 -> 4 -> 6
    l2 = ListNode(2)
    l2.next = ListNode(4)
    l2.next.next = ListNode(6)

    print("List 1: ", end="")
    print_list(l1)

    print("List 2: ", end="")
    print_list(l2)

    merged = merge_two_lists(l1, l2)

    print("Merged list: ", end="")
    print_list(merged)
```
  </Tab>
  <Tab value="javascript">
```javascript
class ListNode {
    constructor(val = 0, next = null) {
        this.val = val;
        this.next = next;
    }
}

function mergeTwoLists(l1, l2) {
    // Create dummy node
    const dummy = new ListNode(0);
    let current = dummy;

    // Merge while both lists have nodes
    while (l1 !== null && l2 !== null) {
        if (l1.val <= l2.val) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }

    // Attach remaining nodes
    current.next = (l1 !== null) ? l1 : l2;

    return dummy.next; // Skip dummy node
}

function printList(head) {
    let current = head;
    let result = "";
    while (current !== null) {
        result += current.val + " -> ";
        current = current.next;
    }
    result += "null";
    console.log(result);
}

// Example usage
// List 1: 1 -> 3 -> 5
const l1 = new ListNode(1);
l1.next = new ListNode(3);
l1.next.next = new ListNode(5);

// List 2: 2 -> 4 -> 6
const l2 = new ListNode(2);
l2.next = new ListNode(4);
l2.next.next = new ListNode(6);

console.log("List 1:");
printList(l1);

console.log("List 2:");
printList(l2);

const merged = mergeTwoLists(l1, l2);

console.log("Merged list:");
printList(merged);
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 2: Recursive (Elegant)" bn="পদ্ধতি ২: রিকার্সিভ (মার্জিত)" />

<TranslatedText
  en="Clean recursive solution that builds the merged list from the end."
  bn="পরিষ্কার রিকার্সিভ সমাধান যা শেষ থেকে মার্জড লিস্ট তৈরি করে।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(m + n)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(m + n) <TranslatedText en="due to recursion stack" bn="রিকার্শন স্ট্যাকের কারণে" />

<Tabs groupId="language" items={['c++', 'python', 'javascript']}>
  <Tab value="c++">
```cpp
ListNode* mergeTwoListsRecursive(ListNode* l1, ListNode* l2) {
    // Base cases
    if (l1 == nullptr) return l2;
    if (l2 == nullptr) return l1;

    // Recursive case
    if (l1->val <= l2->val) {
        l1->next = mergeTwoListsRecursive(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoListsRecursive(l1, l2->next);
        return l2;
    }
}

int main() {
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(3);
    l1->next->next = new ListNode(5);

    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(4);
    l2->next->next = new ListNode(6);

    cout << "List 1: ";
    printList(l1);

    cout << "List 2: ";
    printList(l2);

    ListNode* merged = mergeTwoListsRecursive(l1, l2);

    cout << "Merged list: ";
    printList(merged);

    return 0;
}
```
  </Tab>
  <Tab value="python">
```python
def merge_two_lists_recursive(l1, l2):
    """Merge two sorted lists using recursion"""
    # Base cases
    if l1 is None:
        return l2
    if l2 is None:
        return l1

    # Recursive case
    if l1.val <= l2.val:
        l1.next = merge_two_lists_recursive(l1.next, l2)
        return l1
    else:
        l2.next = merge_two_lists_recursive(l1, l2.next)
        return l2

# Example usage
l1 = ListNode(1)
l1.next = ListNode(3)
l1.next.next = ListNode(5)

l2 = ListNode(2)
l2.next = ListNode(4)
l2.next.next = ListNode(6)

print("List 1: ", end="")
print_list(l1)

print("List 2: ", end="")
print_list(l2)

merged = merge_two_lists_recursive(l1, l2)

print("Merged list: ", end="")
print_list(merged)
```
  </Tab>
  <Tab value="javascript">
```javascript
function mergeTwoListsRecursive(l1, l2) {
    // Base cases
    if (l1 === null) return l2;
    if (l2 === null) return l1;

    // Recursive case
    if (l1.val <= l2.val) {
        l1.next = mergeTwoListsRecursive(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoListsRecursive(l1, l2.next);
        return l2;
    }
}

// Example usage
const l1 = new ListNode(1);
l1.next = new ListNode(3);
l1.next.next = new ListNode(5);

const l2 = new ListNode(2);
l2.next = new ListNode(4);
l2.next.next = new ListNode(6);

console.log("List 1:");
printList(l1);

console.log("List 2:");
printList(l2);

const merged = mergeTwoListsRecursive(l1, l2);

console.log("Merged list:");
printList(merged);
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 3: Merge K Sorted Lists" bn="পদ্ধতি ৩: K সাজানো লিস্ট মার্জ করা" />

<TranslatedText
  en="Extension to merge multiple sorted lists using divide and conquer."
  bn="ডিভাইড এন্ড কনকার ব্যবহার করে একাধিক সাজানো লিস্ট মার্জ করার এক্সটেনশন।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(N log k) <TranslatedText en="where N is total nodes, k is number of lists" bn="যেখানে N হল মোট নোড, k হল লিস্টের সংখ্যা" />
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

<Tabs groupId="language" items={['c++', 'python', 'javascript']}>
  <Tab value="c++">
```cpp
#include <vector>

ListNode* mergeKLists(vector<ListNode*>& lists) {
    if (lists.empty()) return nullptr;

    while (lists.size() > 1) {
        vector<ListNode*> mergedLists;

        for (int i = 0; i < lists.size(); i += 2) {
            ListNode* l1 = lists[i];
            ListNode* l2 = (i + 1 < lists.size()) ? lists[i + 1] : nullptr;
            mergedLists.push_back(mergeTwoLists(l1, l2));
        }

        lists = mergedLists;
    }

    return lists[0];
}

int main() {
    // List 1: 1 -> 4 -> 7
    ListNode* l1 = new ListNode(1);
    l1->next = new ListNode(4);
    l1->next->next = new ListNode(7);

    // List 2: 2 -> 5 -> 8
    ListNode* l2 = new ListNode(2);
    l2->next = new ListNode(5);
    l2->next->next = new ListNode(8);

    // List 3: 3 -> 6 -> 9
    ListNode* l3 = new ListNode(3);
    l3->next = new ListNode(6);
    l3->next->next = new ListNode(9);

    vector<ListNode*> lists = {l1, l2, l3};

    ListNode* merged = mergeKLists(lists);

    cout << "Merged K lists: ";
    printList(merged);

    return 0;
}
```
  </Tab>
  <Tab value="python">
```python
def merge_k_lists(lists):
    """Merge K sorted lists using divide and conquer"""
    if not lists:
        return None

    while len(lists) > 1:
        merged_lists = []

        for i in range(0, len(lists), 2):
            l1 = lists[i]
            l2 = lists[i + 1] if (i + 1 < len(lists)) else None
            merged_lists.append(merge_two_lists(l1, l2))

        lists = merged_lists

    return lists[0]

# Example usage
# List 1: 1 -> 4 -> 7
l1 = ListNode(1)
l1.next = ListNode(4)
l1.next.next = ListNode(7)

# List 2: 2 -> 5 -> 8
l2 = ListNode(2)
l2.next = ListNode(5)
l2.next.next = ListNode(8)

# List 3: 3 -> 6 -> 9
l3 = ListNode(3)
l3.next = ListNode(6)
l3.next.next = ListNode(9)

lists = [l1, l2, l3]

merged = merge_k_lists(lists)

print("Merged K lists: ", end="")
print_list(merged)
```
  </Tab>
  <Tab value="javascript">
```javascript
function mergeKLists(lists) {
    if (lists.length === 0) return null;

    while (lists.length > 1) {
        const mergedLists = [];

        for (let i = 0; i < lists.length; i += 2) {
            const l1 = lists[i];
            const l2 = (i + 1 < lists.length) ? lists[i + 1] : null;
            mergedLists.push(mergeTwoLists(l1, l2));
        }

        lists = mergedLists;
    }

    return lists[0];
}

// Example usage
// List 1: 1 -> 4 -> 7
const l1 = new ListNode(1);
l1.next = new ListNode(4);
l1.next.next = new ListNode(7);

// List 2: 2 -> 5 -> 8
const l2 = new ListNode(2);
l2.next = new ListNode(5);
l2.next.next = new ListNode(8);

// List 3: 3 -> 6 -> 9
const l3 = new ListNode(3);
l3.next = new ListNode(6);
l3.next.next = new ListNode(9);

const lists = [l1, l2, l3];

const merged = mergeKLists(lists);

console.log("Merged K lists:");
printList(merged);
```
  </Tab>
</Tabs>

## <TranslatedText en="Algorithm Walkthrough" bn="অ্যালগরিদম ওয়াকথ্রু" />

<TranslatedText
  en="Let's trace the iterative merge algorithm with List 1: 1 -> 3 -> 5 and List 2: 2 -> 4 -> 6"
  bn="চলুন লিস্ট ১: ১ -> ৩ -> ৫ এবং লিস্ট ২: ২ -> ৪ -> ৬ এর সাথে ইটারেটিভ মার্জ অ্যালগরিদম ট্রেস করি"
/>

```
Initial State:
List 1: 1 -> 3 -> 5
List 2: 2 -> 4 -> 6
Dummy: 0 -> null
Current: dummy

Step 1: Compare 1 and 2
- 1 <= 2, so attach node 1
Result: 0 -> 1
Current: 1
Remaining L1: 3 -> 5
Remaining L2: 2 -> 4 -> 6

Step 2: Compare 3 and 2
- 2 < 3, so attach node 2
Result: 0 -> 1 -> 2
Current: 2
Remaining L1: 3 -> 5
Remaining L2: 4 -> 6

Step 3: Compare 3 and 4
- 3 <= 4, so attach node 3
Result: 0 -> 1 -> 2 -> 3
Current: 3
Remaining L1: 5
Remaining L2: 4 -> 6

Step 4: Compare 5 and 4
- 4 < 5, so attach node 4
Result: 0 -> 1 -> 2 -> 3 -> 4
Current: 4
Remaining L1: 5
Remaining L2: 6

Step 5: Compare 5 and 6
- 5 <= 6, so attach node 5
Result: 0 -> 1 -> 2 -> 3 -> 4 -> 5
Current: 5
Remaining L1: null
Remaining L2: 6

Step 6: Attach remaining (L2)
- L1 is null, attach L2 (6)
Result: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6

Final: Return dummy.next
Result: 1 -> 2 -> 3 -> 4 -> 5 -> 6
```

## <TranslatedText en="Comparison of Approaches" bn="পদ্ধতির তুলনা" />

| <TranslatedText en="Approach" bn="পদ্ধতি" /> | <TranslatedText en="Time Complexity" bn="সময় জটিলতা" /> | <TranslatedText en="Space Complexity" bn="স্থান জটিলতা" /> | <TranslatedText en="Pros" bn="সুবিধা" /> | <TranslatedText en="Cons" bn="অসুবিধা" /> |
|----------|------|-------|------|------|
| Iterative | O(m + n) | O(1) | <TranslatedText en="Optimal, clear logic" bn="সর্বোত্তম, স্পষ্ট লজিক" /> | <TranslatedText en="More code" bn="বেশি কোড" /> |
| Recursive | O(m + n) | O(m + n) | <TranslatedText en="Elegant, concise" bn="মার্জিত, সংক্ষিপ্ত" /> | <TranslatedText en="Stack space overhead" bn="স্ট্যাক স্পেস ওভারহেড" /> |
| Merge K Lists | O(N log k) | O(1) | <TranslatedText en="Handles multiple lists" bn="একাধিক লিস্ট হ্যান্ডল করে" /> | <TranslatedText en="More complex" bn="আরও জটিল" /> |

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

1. **<TranslatedText en="Dummy Node Technique" bn="ডামি নোড কৌশল" />**
   - <TranslatedText en="Simplifies edge case handling (empty lists)" bn="এজ কেস হ্যান্ডলিং সহজ করে (খালি লিস্ট)" />
   - <TranslatedText en="Eliminates need for special first node logic" bn="প্রথম নোড লজিকের জন্য বিশেষ প্রয়োজন দূর করে" />

2. **<TranslatedText en="Sorted Input Requirement" bn="সাজানো ইনপুট প্রয়োজন" />**
   - <TranslatedText en="Both lists MUST be sorted" bn="উভয় লিস্ট সাজানো থাকতে হবে" />
   - <TranslatedText en="Algorithm maintains sorted order" bn="অ্যালগরিদম সাজানো ক্রম বজায় রাখে" />

3. **<TranslatedText en="Stable Sort Property" bn="স্থিতিশীল সাজানো বৈশিষ্ট্য" />**
   - <TranslatedText en="Maintains relative order of equal elements" bn="সমান উপাদানের আপেক্ষিক ক্রম বজায় রাখে" />
   - <TranslatedText en="Uses <= comparison (not just <)" bn="<= তুলনা ব্যবহার করে (শুধু < নয়)" />

4. **<TranslatedText en="In-Place Merging" bn="ইন-প্লেস মার্জিং" />**
   - <TranslatedText en="Reuses existing nodes" bn="বিদ্যমান নোড পুনরায় ব্যবহার করে" />
   - <TranslatedText en="No new node creation needed" bn="নতুন নোড তৈরির প্রয়োজন নেই" />

5. **<TranslatedText en="Attach Remaining Nodes" bn="অবশিষ্ট নোড সংযুক্ত করুন" />**
   - <TranslatedText en="Critical step: attach remaining list when one is exhausted" bn="গুরুত্বপূর্ণ পদক্ষেপ: একটি শেষ হলে অবশিষ্ট লিস্ট সংযুক্ত করুন" />
   - <TranslatedText en="Works because remaining list is already sorted" bn="কাজ করে কারণ অবশিষ্ট লিস্ট ইতিমধ্যে সাজানো" />

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

1. **<TranslatedText en="Ask Clarifying Questions" bn="স্পষ্টকরণ প্রশ্ন জিজ্ঞাসা করুন" />:**
   - <TranslatedText en="Can either list be empty?" bn="কোন লিস্ট খালি হতে পারে?" />
   - <TranslatedText en="Are both lists guaranteed to be sorted?" bn="উভয় লিস্ট সাজানো হওয়ার গ্যারান্টি আছে?" />
   - <TranslatedText en="Should we handle duplicate values?" bn="ডুপ্লিকেট মান হ্যান্ডল করা উচিত?" />

2. **<TranslatedText en="Discuss Trade-offs" bn="ট্রেড-অফ আলোচনা করুন" />:**
   - <TranslatedText en="Iterative vs Recursive" bn="ইটারেটিভ বনাম রিকার্সিভ" />
   - <TranslatedText en="Space complexity differences" bn="স্থান জটিলতার পার্থক্য" />

3. **<TranslatedText en="Test Edge Cases" bn="এজ কেস পরীক্ষা করুন" />:**
   - <TranslatedText en="Both empty lists" bn="উভয় খালি লিস্ট" />
   - <TranslatedText en="One empty list" bn="একটি খালি লিস্ট" />
   - <TranslatedText en="Different length lists" bn="বিভিন্ন দৈর্ঘ্যের লিস্ট" />
   - <TranslatedText en="Lists with all equal elements" bn="সব সমান উপাদান সহ লিস্ট" />

4. **<TranslatedText en="Mention Applications" bn="অ্যাপ্লিকেশন উল্লেখ করুন" />:**
   - <TranslatedText en="Merge sort for linked lists" bn="লিঙ্কড লিস্টের জন্য মার্জ সাজানো" />
   - <TranslatedText en="External sorting" bn="বাহ্যিক সাজানো" />
   - <TranslatedText en="Combining sorted data streams" bn="সাজানো ডেটা স্ট্রিম একত্রিত করা" />

## <TranslatedText en="Common Pitfalls" bn="সাধারণ সমস্যা" />

1. **<TranslatedText en="Not Handling Empty Lists" bn="খালি লিস্ট হ্যান্ডল না করা" />**
   ```cpp
   // Wrong - crashes with null pointer
   if (l1->val <= l2->val)

   // Correct - check for null first
   if (l1 != nullptr && l2 != nullptr)
   ```

2. **<TranslatedText en="Forgetting to Attach Remaining Nodes" bn="অবশিষ্ট নোড সংযুক্ত করতে ভুলে যাওয়া" />**
   ```python
   # Wrong - loses remaining nodes
   while l1 and l2:
       # merge logic
   return dummy.next

   # Correct - attach remaining
   while l1 and l2:
       # merge logic
   current.next = l1 if l1 else l2
   return dummy.next
   ```

3. **<TranslatedText en="Creating Unnecessary New Nodes" bn="অপ্রয়োজনীয় নতুন নোড তৈরি করা" />**
   ```javascript
   // Wrong - creates extra nodes
   current.next = new ListNode(l1.val);

   // Correct - reuse existing nodes
   current.next = l1;
   ```

4. **<TranslatedText en="Using < Instead of <=" bn="<= এর পরিবর্তে < ব্যবহার করা" />**
   ```python
   # Wrong - not stable for equal elements
   if l1.val < l2.val:

   # Correct - maintains stability
   if l1.val <= l2.val:
   ```

5. **<TranslatedText en="Not Returning dummy.next" bn="dummy.next রিটার্ন না করা" />**
   ```cpp
   // Wrong - returns dummy node
   return &dummy;

   // Correct - skips dummy
   return dummy.next;
   ```

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

1. **<TranslatedText en="Dummy node technique is invaluable for linked list problems" bn="ডামি নোড কৌশল লিঙ্কড লিস্ট সমস্যার জন্য অমূল্য" />**
2. **<TranslatedText en="Always check for null/empty lists first" bn="সর্বদা প্রথমে null/খালি লিস্ট পরীক্ষা করুন" />**
3. **<TranslatedText en="Iterative approach is optimal with O(1) space" bn="ইটারেটিভ পদ্ধতি O(1) স্থান সহ সর্বোত্তম" />**
4. **<TranslatedText en="Recursive solution is elegant but uses O(m + n) stack space" bn="রিকার্সিভ সমাধান মার্জিত কিন্তু O(m + n) স্ট্যাক স্থান ব্যবহার করে" />**
5. **<TranslatedText en="Don't forget to attach remaining nodes after loop" bn="লুপের পরে অবশিষ্ট নোড সংযুক্ত করতে ভুলবেন না" />**
6. **<TranslatedText en="This pattern extends to merge K sorted lists with divide & conquer" bn="এই প্যাটার্ন ডিভাইড এন্ড কনকার দিয়ে K সাজানো লিস্ট মার্জ করার জন্য প্রসারিত হয়" />**

## <TranslatedText en="Reference" bn="তথ্যসূত্র" />

[GeeksforGeeks - Merge Two Sorted Lists](https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/)
