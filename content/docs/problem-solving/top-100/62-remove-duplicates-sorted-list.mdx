---
title: 62. Remove Duplicates from Sorted List
description: Remove all duplicate nodes from a sorted linked list, keeping only distinct values
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="Remove Duplicates from Sorted List" bn="সাজানো লিস্ট থেকে ডুপ্লিকেট সরান" />

<TranslatedText
  en="Remove all duplicate values from a sorted linked list, leaving only distinct numbers appearing once."
  bn="একটি সাজানো লিঙ্কড লিস্ট থেকে সমস্ত ডুপ্লিকেট মান সরান, শুধুমাত্র একবার প্রদর্শিত স্বতন্ত্র সংখ্যা রেখে।"
/>

## <TranslatedText en="Problem Statement" bn="সমস্যার বিবৃতি" />

<TranslatedText
  en="Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well."
  bn="একটি সাজানো লিঙ্কড লিস্টের হেড দেওয়া হলে, সমস্ত ডুপ্লিকেট মুছুন যাতে প্রতিটি উপাদান শুধুমাত্র একবার প্রদর্শিত হয়। লিঙ্কড লিস্টটি সাজানোও ফেরত দিন।"
/>

### <TranslatedText en="Example" bn="উদাহরণ" />

```
Input: 1 → 1 → 2
Output: 1 → 2

Input: 1 → 1 → 2 → 3 → 3
Output: 1 → 2 → 3

Input: 1 → 1 → 1
Output: 1

Input: 1 → 2 → 3
Output: 1 → 2 → 3
```

## <TranslatedText en="Approach 1: Single Pointer (Recommended)" bn="পদ্ধতি ১: একক পয়েন্টার (প্রস্তাবিত)" />

<TranslatedText
  en="Since the list is sorted, duplicates are adjacent. Use a single pointer to skip over duplicate nodes."
  bn="যেহেতু লিস্ট সাজানো আছে, ডুপ্লিকেটগুলি সংলগ্ন। ডুপ্লিকেট নোড এড়িয়ে যেতে একটি একক পয়েন্টার ব্যবহার করুন।"
/>

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* deleteDuplicates(Node* head) {
    if (!head) return nullptr;

    Node* curr = head;

    while (curr && curr->next) {
        if (curr->data == curr->next->data) {
            // Duplicate found, skip the next node
            Node* temp = curr->next;
            curr->next = curr->next->next;
            delete temp;
        } else {
            // No duplicate, move to next node
            curr = curr->next;
        }
    }

    return head;
}

// Helper function to create linked list
Node* createList(int arr[], int n) {
    if (n == 0) return nullptr;
    Node* head = new Node(arr[0]);
    Node* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new Node(arr[i]);
        curr = curr->next;
    }
    return head;
}

// Helper function to print list
void printList(Node* head) {
    if (!head) {
        cout << "[]" << endl;
        return;
    }
    while (head) {
        cout << head->data;
        if (head->next) cout << " → ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Test case 1: Two duplicates
    int arr1[] = {1, 1, 2};
    Node* head1 = createList(arr1, 3);
    cout << "Original: ";
    printList(head1);
    head1 = deleteDuplicates(head1);
    cout << "After removing duplicates: ";
    printList(head1);

    // Test case 2: Multiple duplicates
    int arr2[] = {1, 1, 2, 3, 3};
    Node* head2 = createList(arr2, 5);
    cout << "\nOriginal: ";
    printList(head2);
    head2 = deleteDuplicates(head2);
    cout << "After removing duplicates: ";
    printList(head2);

    // Test case 3: All duplicates
    int arr3[] = {1, 1, 1};
    Node* head3 = createList(arr3, 3);
    cout << "\nOriginal: ";
    printList(head3);
    head3 = deleteDuplicates(head3);
    cout << "After removing duplicates: ";
    printList(head3);

    // Test case 4: No duplicates
    int arr4[] = {1, 2, 3};
    Node* head4 = createList(arr4, 3);
    cout << "\nOriginal: ";
    printList(head4);
    head4 = deleteDuplicates(head4);
    cout << "After removing duplicates: ";
    printList(head4);

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def delete_duplicates(head):
    if not head:
        return None

    curr = head

    while curr and curr.next:
        if curr.data == curr.next.data:
            # Duplicate found, skip the next node
            curr.next = curr.next.next
        else:
            # No duplicate, move to next node
            curr = curr.next

    return head

# Helper function to create linked list
def create_list(arr):
    if not arr:
        return None
    head = Node(arr[0])
    curr = head
    for val in arr[1:]:
        curr.next = Node(val)
        curr = curr.next
    return head

# Helper function to print list
def print_list(head):
    if not head:
        print("[]")
        return
    result = []
    while head:
        result.append(str(head.data))
        head = head.next
    print(" → ".join(result))

# Test case 1: Two duplicates
head1 = create_list([1, 1, 2])
print("Original:", end=" ")
print_list(head1)
head1 = delete_duplicates(head1)
print("After removing duplicates:", end=" ")
print_list(head1)

# Test case 2: Multiple duplicates
head2 = create_list([1, 1, 2, 3, 3])
print("\nOriginal:", end=" ")
print_list(head2)
head2 = delete_duplicates(head2)
print("After removing duplicates:", end=" ")
print_list(head2)

# Test case 3: All duplicates
head3 = create_list([1, 1, 1])
print("\nOriginal:", end=" ")
print_list(head3)
head3 = delete_duplicates(head3)
print("After removing duplicates:", end=" ")
print_list(head3)

# Test case 4: No duplicates
head4 = create_list([1, 2, 3])
print("\nOriginal:", end=" ")
print_list(head4)
head4 = delete_duplicates(head4)
print("After removing duplicates:", end=" ")
print_list(head4)
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function deleteDuplicates(head) {
    if (!head) return null;

    let curr = head;

    while (curr && curr.next) {
        if (curr.data === curr.next.data) {
            // Duplicate found, skip the next node
            curr.next = curr.next.next;
        } else {
            // No duplicate, move to next node
            curr = curr.next;
        }
    }

    return head;
}

// Helper function to create linked list
function createList(arr) {
    if (arr.length === 0) return null;
    const head = new Node(arr[0]);
    let curr = head;
    for (let i = 1; i < arr.length; i++) {
        curr.next = new Node(arr[i]);
        curr = curr.next;
    }
    return head;
}

// Helper function to print list
function printList(head) {
    if (!head) {
        console.log("[]");
        return;
    }
    const result = [];
    while (head) {
        result.push(head.data);
        head = head.next;
    }
    console.log(result.join(" → "));
}

// Test case 1: Two duplicates
let head1 = createList([1, 1, 2]);
console.log("Original:");
printList(head1);
head1 = deleteDuplicates(head1);
console.log("After removing duplicates:");
printList(head1);

// Test case 2: Multiple duplicates
let head2 = createList([1, 1, 2, 3, 3]);
console.log("\nOriginal:");
printList(head2);
head2 = deleteDuplicates(head2);
console.log("After removing duplicates:");
printList(head2);

// Test case 3: All duplicates
let head3 = createList([1, 1, 1]);
console.log("\nOriginal:");
printList(head3);
head3 = deleteDuplicates(head3);
console.log("After removing duplicates:");
printList(head3);

// Test case 4: No duplicates
let head4 = createList([1, 2, 3]);
console.log("\nOriginal:");
printList(head4);
head4 = deleteDuplicates(head4);
console.log("After removing duplicates:");
printList(head4);
```
  </Tab>
</Tabs>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n) <TranslatedText en="where n is the number of nodes" bn="যেখানে n হল নোডের সংখ্যা" />

**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

## <TranslatedText en="Approach 2: Recursive Solution" bn="পদ্ধতি ২: পুনরাবৃত্ত সমাধান" />

<TranslatedText
  en="A recursive approach that elegantly handles duplicates by processing the rest of the list first."
  bn="একটি পুনরাবৃত্ত পদ্ধতি যা প্রথমে বাকি লিস্ট প্রক্রিয়া করে মার্জন্টভাবে ডুপ্লিকেট হ্যান্ডেল করে।"
/>

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
Node* deleteDuplicatesRecursive(Node* head) {
    if (!head || !head->next) return head;

    // Recursively process the rest
    head->next = deleteDuplicatesRecursive(head->next);

    // If current and next are duplicates, skip current
    if (head->data == head->next->data) {
        Node* temp = head->next;
        head->next = head->next->next;
        delete temp;
    }

    return head;
}
```
  </Tab>
  <Tab value="Python">
```python
def delete_duplicates_recursive(head):
    if not head or not head.next:
        return head

    # Recursively process the rest
    head.next = delete_duplicates_recursive(head.next)

    # If current and next are duplicates, skip next
    if head.data == head.next.data:
        head.next = head.next.next

    return head
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function deleteDuplicatesRecursive(head) {
    if (!head || !head.next) return head;

    // Recursively process the rest
    head.next = deleteDuplicatesRecursive(head.next);

    // If current and next are duplicates, skip next
    if (head.data === head.next.data) {
        head.next = head.next.next;
    }

    return head;
}
```
  </Tab>
</Tabs>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n)

**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(n) <TranslatedText en="due to recursion call stack" bn="পুনরাবৃত্তি কল স্ট্যাকের কারণে" />

## <TranslatedText en="How It Works" bn="এটি কীভাবে কাজ করে" />

<TranslatedText
  en="The algorithm compares each node with its next node:"
  bn="অ্যালগরিদম প্রতিটি নোডকে তার পরবর্তী নোডের সাথে তুলনা করে:"
/>

```
Example: Remove duplicates from 1 → 1 → 2 → 3 → 3

Initial: curr = 1
         1 → 1 → 2 → 3 → 3
         ^
         curr

Step 1: curr.data (1) == curr.next.data (1)
        Duplicate! Skip the next node
        1 → 2 → 3 → 3
        ^
        curr
        (Don't move curr, check again)

Step 2: curr.data (1) != curr.next.data (2)
        No duplicate, move curr forward
        1 → 2 → 3 → 3
            ^
            curr

Step 3: curr.data (2) != curr.next.data (3)
        No duplicate, move curr forward
        1 → 2 → 3 → 3
                ^
                curr

Step 4: curr.data (3) == curr.next.data (3)
        Duplicate! Skip the next node
        1 → 2 → 3
                ^
                curr

Step 5: curr.next is null, stop

Result: 1 → 2 → 3
```

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Sorted list property</strong>: Duplicates are always adjacent, simplifying detection</li>
        <li><strong>Stay in place on duplicate</strong>: Don't advance curr when deleting, check again</li>
        <li><strong>No extra space needed</strong>: Can modify list in-place</li>
        <li><strong>Keep first occurrence</strong>: We keep the current node and delete duplicates ahead</li>
        <li><strong>Simple logic</strong>: Much simpler than unsorted list duplicate removal</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>সাজানো লিস্ট বৈশিষ্ট্য</strong>: ডুপ্লিকেটগুলি সর্বদা সংলগ্ন, সনাক্তকরণ সরল করে</li>
        <li><strong>ডুপ্লিকেটে স্থানে থাকুন</strong>: মুছে ফেলার সময় curr এগিয়ে যাবেন না, আবার চেক করুন</li>
        <li><strong>অতিরিক্ত স্থান প্রয়োজন নেই</strong>: ইন-প্লেস লিস্ট পরিবর্তন করতে পারে</li>
        <li><strong>প্রথম ঘটনা রাখুন</strong>: আমরা বর্তমান নোড রাখি এবং এগিয়ে ডুপ্লিকেট মুছি</li>
        <li><strong>সরল লজিক</strong>: অসাজানো লিস্ট ডুপ্লিকেট অপসারণের চেয়ে অনেক সহজ</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Edge Cases to Consider" bn="বিবেচনা করার জন্য এজ কেস" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Empty list</strong>: Return null</li>
        <li><strong>Single node</strong>: Return as is (no duplicates possible)</li>
        <li><strong>No duplicates</strong>: List remains unchanged</li>
        <li><strong>All duplicates</strong>: Return single node with that value</li>
        <li><strong>Multiple consecutive duplicates</strong>: Keep removing until different value found</li>
        <li><strong>Duplicates at end</strong>: Handle correctly when curr.next becomes null</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>খালি লিস্ট</strong>: null ফেরত দিন</li>
        <li><strong>একক নোড</strong>: যেমন আছে তেমন ফেরত দিন (ডুপ্লিকেট সম্ভব নয়)</li>
        <li><strong>কোন ডুপ্লিকেট নেই</strong>: লিস্ট অপরিবর্তিত থাকে</li>
        <li><strong>সব ডুপ্লিকেট</strong>: সেই মান সহ একক নোড ফেরত দিন</li>
        <li><strong>একাধিক পরপর ডুপ্লিকেট</strong>: বিভিন্ন মান পাওয়া পর্যন্ত মুছতে থাকুন</li>
        <li><strong>শেষে ডুপ্লিকেট</strong>: curr.next null হলে সঠিকভাবে হ্যান্ডেল করুন</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Mention sorted property</strong>: Emphasize how it simplifies the problem</li>
        <li><strong>Explain pointer movement</strong>: Why we don't advance curr when deleting</li>
        <li><strong>Compare with unsorted</strong>: Sorted version is O(n) time O(1) space, unsorted needs O(n) space</li>
        <li><strong>Discuss both approaches</strong>: Iterative (better space) vs Recursive (cleaner code)</li>
        <li><strong>Mention variant</strong>: LeetCode has a harder version that removes ALL occurrences of duplicates</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>সাজানো বৈশিষ্ট্য উল্লেখ করুন</strong>: জোর দিন কিভাবে এটি সমস্যা সরল করে</li>
        <li><strong>পয়েন্টার চলাচল ব্যাখ্যা করুন</strong>: কেন আমরা মুছে ফেলার সময় curr এগিয়ে যাই না</li>
        <li><strong>অসাজানোর সাথে তুলনা করুন</strong>: সাজানো সংস্করণ O(n) সময় O(1) স্থান, অসাজানো O(n) স্থান প্রয়োজন</li>
        <li><strong>উভয় পদ্ধতি আলোচনা করুন</strong>: পুনরাবৃত্তিমূলক (ভাল স্থান) বনাম পুনরাবৃত্ত (পরিষ্কার কোড)</li>
        <li><strong>বৈকল্পিক উল্লেখ করুন</strong>: LeetCode এ একটি কঠিন সংস্করণ আছে যা ডুপ্লিকেটের সমস্ত ঘটনা সরিয়ে দেয়</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Common Mistakes to Avoid" bn="এড়ানোর জন্য সাধারণ ভুল" />

<TranslatedText
  en={
    <>
      <ul>
        <li>Moving curr forward when deleting (causes skipping a duplicate check)</li>
        <li>Not handling null/empty list</li>
        <li>Not checking curr.next before accessing curr.next.data</li>
        <li>Forgetting to delete removed nodes in C++ (memory leak)</li>
        <li>Using extra space (hash set) when not needed for sorted list</li>
        <li>Modifying values instead of removing nodes</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li>মুছে ফেলার সময় curr এগিয়ে নিয়ে যাওয়া (একটি ডুপ্লিকেট চেক এড়িয়ে যায়)</li>
        <li>null/খালি লিস্ট হ্যান্ডেল না করা</li>
        <li>curr.next.data অ্যাক্সেস করার আগে curr.next চেক না করা</li>
        <li>C++ এ সরানো নোড মুছতে ভুলে যাওয়া (মেমরি লিক)</li>
        <li>সাজানো লিস্টের জন্য প্রয়োজন না থাকলে অতিরিক্ত স্থান (হ্যাশ সেট) ব্যবহার করা</li>
        <li>নোড সরানোর পরিবর্তে মান পরিবর্তন করা</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Related Problems" bn="সম্পর্কিত সমস্যা" />

- Remove duplicates from unsorted linked list (requires hash set, O(n) space)
- Remove duplicates from sorted array
- Remove all duplicate nodes (harder: remove nodes that have duplicates entirely)
- Remove duplicates from sorted list II (keep only unique values)

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

<TranslatedText
  en={
    <>
      <ul>
        <li>Sorted property makes duplicate detection trivial - just check adjacent nodes</li>
        <li>Stay in place when deleting to handle consecutive duplicates</li>
        <li>O(n) time with O(1) space - optimal for sorted list</li>
        <li>Much simpler than unsorted list duplicate removal</li>
        <li>Iterative approach is preferred for constant space</li>
        <li>This pattern is fundamental for sorted list manipulation</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li>সাজানো বৈশিষ্ট্য ডুপ্লিকেট সনাক্তকরণ তুচ্ছ করে তোলে - শুধু সংলগ্ন নোড চেক করুন</li>
        <li>পরপর ডুপ্লিকেট হ্যান্ডেল করতে মুছে ফেলার সময় স্থানে থাকুন</li>
        <li>O(n) সময় O(1) স্থান সহ - সাজানো লিস্টের জন্য সর্বোত্তম</li>
        <li>অসাজানো লিস্ট ডুপ্লিকেট অপসারণের চেয়ে অনেক সহজ</li>
        <li>পুনরাবৃত্তিমূলক পদ্ধতি ধ্রুবক স্থানের জন্য পছন্দনীয়</li>
        <li>এই প্যাটার্ন সাজানো লিস্ট ম্যানিপুলেশনের জন্য মৌলিক</li>
      </ul>
    </>
  }
/>
