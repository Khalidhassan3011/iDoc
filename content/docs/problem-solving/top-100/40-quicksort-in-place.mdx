---
title: 40. Quicksort Algorithm In Place
description: How to sort an integer array in place using the quicksort algorithm
---

## Problem Statement

Implement the quicksort algorithm to sort an integer array in place. Quicksort is a divide-and-conquer algorithm that picks a pivot element and partitions the array around the pivot.

## Algorithm Overview

1. **Choose a pivot** element from the array
2. **Partition** the array so that:
   - Elements less than pivot are on the left
   - Elements greater than pivot are on the right
3. **Recursively** apply the same process to the left and right subarrays

## Examples

### Example 1
```
Input: [64, 34, 25, 12, 22, 11, 90]
Output: [11, 12, 22, 25, 34, 64, 90]
```

### Example 2
```
Input: [5, 2, 8, 1, 9]
Output: [1, 2, 5, 8, 9]
```

### Example 3
```
Input: [3, 3, 1, 2, 3]
Output: [1, 2, 3, 3, 3]
```

## Solution

### Approach 1: Classic Quicksort with Last Element as Pivot

**Time Complexity:**
- Average: O(n log n)
- Worst: O(n²) when array is already sorted
**Space Complexity:** O(log n) for recursion stack

```dart
void quickSort(List<int> arr, int low, int high) {
  if (low < high) {
    // Partition the array and get pivot index
    int pivotIndex = partition(arr, low, high);

    // Recursively sort elements before and after partition
    quickSort(arr, low, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, high);
  }
}

int partition(List<int> arr, int low, int high) {
  // Choose the last element as pivot
  int pivot = arr[high];
  int i = low - 1; // Index of smaller element

  for (int j = low; j < high; j++) {
    // If current element is less than or equal to pivot
    if (arr[j] <= pivot) {
      i++;
      // Swap arr[i] and arr[j]
      int temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }
  }

  // Swap arr[i+1] and arr[high] (put pivot in correct position)
  int temp = arr[i + 1];
  arr[i + 1] = arr[high];
  arr[high] = temp;

  return i + 1;
}

void main() {
  List<int> arr = [64, 34, 25, 12, 22, 11, 90];
  print('Original array: $arr');

  quickSort(arr, 0, arr.length - 1);
  print('Sorted array: $arr');

  // Test with duplicates
  List<int> arr2 = [3, 3, 1, 2, 3];
  print('\nOriginal array: $arr2');
  quickSort(arr2, 0, arr2.length - 1);
  print('Sorted array: $arr2');
}
```

### Approach 2: Quicksort with Random Pivot

Choosing a random pivot helps avoid worst-case O(n²) for sorted arrays.

**Time Complexity:**
- Average: O(n log n)
- Worst: O(n²) (unlikely with random pivot)
**Space Complexity:** O(log n)

```dart
import 'dart:math';

void quickSortRandom(List<int> arr, int low, int high) {
  if (low < high) {
    int pivotIndex = partitionRandom(arr, low, high);
    quickSortRandom(arr, low, pivotIndex - 1);
    quickSortRandom(arr, pivotIndex + 1, high);
  }
}

int partitionRandom(List<int> arr, int low, int high) {
  // Choose random pivot and swap with last element
  Random random = Random();
  int randomIndex = low + random.nextInt(high - low + 1);

  // Swap random element with last element
  int temp = arr[randomIndex];
  arr[randomIndex] = arr[high];
  arr[high] = temp;

  // Now use standard partition with last element as pivot
  return partition(arr, low, high);
}

void main() {
  List<int> arr = [64, 34, 25, 12, 22, 11, 90];
  print('Original array: $arr');

  quickSortRandom(arr, 0, arr.length - 1);
  print('Sorted array: $arr');
}
```

### Approach 3: Quicksort with Median-of-Three Pivot

Choose the median of first, middle, and last elements as pivot.

**Time Complexity:** O(n log n) average, better pivot selection
**Space Complexity:** O(log n)

```dart
void quickSortMedian(List<int> arr, int low, int high) {
  if (low < high) {
    int pivotIndex = partitionMedian(arr, low, high);
    quickSortMedian(arr, low, pivotIndex - 1);
    quickSortMedian(arr, pivotIndex + 1, high);
  }
}

int medianOfThree(List<int> arr, int low, int high) {
  int mid = low + (high - low) ~/ 2;

  // Sort low, mid, high
  if (arr[low] > arr[mid]) {
    swap(arr, low, mid);
  }
  if (arr[low] > arr[high]) {
    swap(arr, low, high);
  }
  if (arr[mid] > arr[high]) {
    swap(arr, mid, high);
  }

  // Place median at high-1 position
  swap(arr, mid, high);
  return high;
}

void swap(List<int> arr, int i, int j) {
  int temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}

int partitionMedian(List<int> arr, int low, int high) {
  medianOfThree(arr, low, high);
  return partition(arr, low, high);
}

void main() {
  List<int> arr = [64, 34, 25, 12, 22, 11, 90];
  print('Original array: $arr');

  quickSortMedian(arr, 0, arr.length - 1);
  print('Sorted array: $arr');
}
```

### Approach 4: Three-Way Quicksort (Dutch National Flag)

Efficient for arrays with many duplicate elements.

**Time Complexity:** O(n log n), better with duplicates
**Space Complexity:** O(log n)

```dart
void quickSort3Way(List<int> arr, int low, int high) {
  if (low >= high) return;

  // Partition into three parts
  var result = partition3Way(arr, low, high);
  int lt = result[0]; // Less than region end
  int gt = result[1]; // Greater than region start

  quickSort3Way(arr, low, lt);
  quickSort3Way(arr, gt, high);
}

List<int> partition3Way(List<int> arr, int low, int high) {
  int pivot = arr[low];
  int lt = low;      // arr[low..lt-1] < pivot
  int i = low + 1;   // arr[lt..i-1] == pivot
  int gt = high;     // arr[gt+1..high] > pivot

  while (i <= gt) {
    if (arr[i] < pivot) {
      swap(arr, lt++, i++);
    } else if (arr[i] > pivot) {
      swap(arr, i, gt--);
    } else {
      i++;
    }
  }

  return [lt, gt + 1];
}

void main() {
  List<int> arr = [3, 5, 2, 3, 8, 3, 1, 3, 9];
  print('Original array: $arr');

  quickSort3Way(arr, 0, arr.length - 1);
  print('Sorted array: $arr');
}
```

### Approach 5: Iterative Quicksort (Without Recursion)

Uses a stack to avoid recursion.

**Time Complexity:** O(n log n) average
**Space Complexity:** O(log n) for stack

```dart
void quickSortIterative(List<int> arr) {
  if (arr.length <= 1) return;

  List<int> stack = [];
  stack.add(0);
  stack.add(arr.length - 1);

  while (stack.isNotEmpty) {
    int high = stack.removeLast();
    int low = stack.removeLast();

    if (low < high) {
      int pivotIndex = partition(arr, low, high);

      // Push left subarray bounds
      stack.add(low);
      stack.add(pivotIndex - 1);

      // Push right subarray bounds
      stack.add(pivotIndex + 1);
      stack.add(high);
    }
  }
}

void main() {
  List<int> arr = [64, 34, 25, 12, 22, 11, 90];
  print('Original array: $arr');

  quickSortIterative(arr);
  print('Sorted array: $arr');
}
```

## Comparison of Approaches

| Approach | Avg Time | Worst Time | Best For |
|----------|----------|------------|----------|
| Last Element Pivot | O(n log n) | O(n²) | General use, simple |
| Random Pivot | O(n log n) | O(n²)* | Avoid worst case |
| Median-of-Three | O(n log n) | O(n log n)* | Better pivot choice |
| Three-Way | O(n log n) | O(n log n) | Many duplicates |
| Iterative | O(n log n) | O(n²) | Avoid recursion limits |

\* Less likely to hit worst case

## Key Characteristics of Quicksort

**Advantages:**
- Fast average-case performance O(n log n)
- In-place sorting (no extra array needed)
- Cache-friendly
- Good for large datasets

**Disadvantages:**
- O(n²) worst case (already sorted with bad pivot)
- Not stable (relative order of equal elements may change)
- Recursive implementation uses stack space

## Partition Visualization

For array [64, 34, 25, 12, 22, 11, 90] with pivot = 90:

```
Initial: [64, 34, 25, 12, 22, 11, 90]

After partition:
[64, 34, 25, 12, 22, 11] [90] []
         ↓                pivot  ↓
    (less than 90)              (greater than 90)
```

## Common Pitfalls

- Choosing bad pivot (first/last element in sorted array)
- Not handling duplicates efficiently
- Off-by-one errors in partition logic
- Stack overflow with deep recursion on large arrays
- Not checking for empty or single-element arrays

## Test Cases

```dart
void testQuickSort() {
  // Test case 1: Random array
  List<int> arr1 = [64, 34, 25, 12, 22, 11, 90];
  quickSort(arr1, 0, arr1.length - 1);
  print('Test 1: $arr1');

  // Test case 2: Already sorted
  List<int> arr2 = [1, 2, 3, 4, 5];
  quickSort(arr2, 0, arr2.length - 1);
  print('Test 2: $arr2');

  // Test case 3: Reverse sorted
  List<int> arr3 = [5, 4, 3, 2, 1];
  quickSort(arr3, 0, arr3.length - 1);
  print('Test 3: $arr3');

  // Test case 4: With duplicates
  List<int> arr4 = [3, 3, 1, 2, 3];
  quickSort(arr4, 0, arr4.length - 1);
  print('Test 4: $arr4');

  // Test case 5: Single element
  List<int> arr5 = [1];
  quickSort(arr5, 0, arr5.length - 1);
  print('Test 5: $arr5');

  // Test case 6: Empty array
  List<int> arr6 = [];
  quickSort(arr6, 0, arr6.length - 1);
  print('Test 6: $arr6');
}
```

## Reference

[JavaRevisited - Quicksort Algorithm](http://javarevisited.blogspot.com/2014/08/quicksort-sorting-algorithm-in-java-in-place-example.html)
