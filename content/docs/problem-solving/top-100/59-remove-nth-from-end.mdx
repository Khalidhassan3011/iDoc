---
title: 59. Remove Nth Node from End
description: Remove the Nth node from the end of a singly linked list in one pass
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="Remove Nth Node from End" bn="শেষ থেকে Nth নোড সরান" />

<TranslatedText
  en="Remove the Nth node from the end of a singly linked list in a single traversal using the two-pointer technique."
  bn="টু-পয়েন্টার কৌশল ব্যবহার করে একটি একক ট্রাভার্সালে সিঙ্গলি লিঙ্কড লিস্টের শেষ থেকে Nth নোড সরান।"
/>

## <TranslatedText en="Problem Statement" bn="সমস্যার বিবৃতি" />

<TranslatedText
  en="Given the head of a linked list, remove the nth node from the end of the list and return its head. You must solve this in one pass (single traversal)."
  bn="একটি লিঙ্কড লিস্টের হেড দেওয়া হলে, লিস্টের শেষ থেকে nth নোড সরান এবং এর হেড ফেরত দিন। আপনাকে অবশ্যই এটি এক পাসে (একক ট্রাভার্সাল) সমাধান করতে হবে।"
/>

### <TranslatedText en="Example" bn="উদাহরণ" />

```
Input: 1 → 2 → 3 → 4 → 5, n = 2
Output: 1 → 2 → 3 → 5
Explanation: Remove 4 (2nd from end)

Input: 1 → 2 → 3 → 4 → 5, n = 5
Output: 2 → 3 → 4 → 5
Explanation: Remove 1 (5th from end, i.e., head)

Input: 1, n = 1
Output: null
Explanation: Only one node, remove it
```

## <TranslatedText en="Approach 1: Two Pointer with Dummy Node (Recommended)" bn="পদ্ধতি ১: ডামি নোড সহ দুটি পয়েন্টার (প্রস্তাবিত)" />

<TranslatedText
  en="Use a dummy node to simplify head deletion. Move fast pointer n steps ahead, then move both pointers together. When fast reaches the end, slow is right before the node to delete."
  bn="হেড ডিলিশন সরল করতে একটি ডামি নোড ব্যবহার করুন। দ্রুত পয়েন্টারকে n ধাপ এগিয়ে নিয়ে যান, তারপর উভয় পয়েন্টারকে একসাথে সরান। যখন দ্রুত শেষে পৌঁছায়, ধীর মুছে ফেলার নোডের ঠিক আগে থাকে।"
/>

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
using namespace std;

struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

Node* removeNthFromEnd(Node* head, int n) {
    // Use dummy node to handle edge cases uniformly
    Node* dummy = new Node(0);
    dummy->next = head;

    Node* fast = dummy;
    Node* slow = dummy;

    // Move fast n+1 steps ahead so slow stops before node to delete
    for (int i = 0; i <= n; i++) {
        if (!fast) return head; // n is larger than list length
        fast = fast->next;
    }

    // Move both pointers together
    while (fast) {
        slow = slow->next;
        fast = fast->next;
    }

    // Delete the nth node from end
    Node* toDelete = slow->next;
    slow->next = slow->next->next;
    delete toDelete;

    Node* newHead = dummy->next;
    delete dummy;
    return newHead;
}

// Helper function to create linked list
Node* createList(int arr[], int n) {
    if (n == 0) return nullptr;
    Node* head = new Node(arr[0]);
    Node* curr = head;
    for (int i = 1; i < n; i++) {
        curr->next = new Node(arr[i]);
        curr = curr->next;
    }
    return head;
}

// Helper function to print list
void printList(Node* head) {
    while (head) {
        cout << head->data;
        if (head->next) cout << " → ";
        head = head->next;
    }
    cout << endl;
}

int main() {
    // Test case 1: Remove 2nd from end
    int arr1[] = {1, 2, 3, 4, 5};
    Node* head1 = createList(arr1, 5);
    cout << "Original list: ";
    printList(head1);
    head1 = removeNthFromEnd(head1, 2);
    cout << "After removing 2nd from end: ";
    printList(head1);

    // Test case 2: Remove head (5th from end)
    int arr2[] = {1, 2, 3, 4, 5};
    Node* head2 = createList(arr2, 5);
    cout << "\nOriginal list: ";
    printList(head2);
    head2 = removeNthFromEnd(head2, 5);
    cout << "After removing 5th from end: ";
    printList(head2);

    // Test case 3: Single node
    int arr3[] = {1};
    Node* head3 = createList(arr3, 1);
    cout << "\nOriginal list: ";
    printList(head3);
    head3 = removeNthFromEnd(head3, 1);
    cout << "After removing 1st from end: ";
    if (head3) printList(head3);
    else cout << "null" << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def remove_nth_from_end(head, n):
    # Use dummy node to handle edge cases uniformly
    dummy = Node(0)
    dummy.next = head

    fast = dummy
    slow = dummy

    # Move fast n+1 steps ahead so slow stops before node to delete
    for i in range(n + 1):
        if not fast:
            return head  # n is larger than list length
        fast = fast.next

    # Move both pointers together
    while fast:
        slow = slow.next
        fast = fast.next

    # Delete the nth node from end
    slow.next = slow.next.next

    return dummy.next

# Helper function to create linked list
def create_list(arr):
    if not arr:
        return None
    head = Node(arr[0])
    curr = head
    for val in arr[1:]:
        curr.next = Node(val)
        curr = curr.next
    return head

# Helper function to print list
def print_list(head):
    result = []
    while head:
        result.append(str(head.data))
        head = head.next
    print(" → ".join(result) if result else "null")

# Test case 1: Remove 2nd from end
head1 = create_list([1, 2, 3, 4, 5])
print("Original list:", end=" ")
print_list(head1)
head1 = remove_nth_from_end(head1, 2)
print("After removing 2nd from end:", end=" ")
print_list(head1)

# Test case 2: Remove head (5th from end)
head2 = create_list([1, 2, 3, 4, 5])
print("\nOriginal list:", end=" ")
print_list(head2)
head2 = remove_nth_from_end(head2, 5)
print("After removing 5th from end:", end=" ")
print_list(head2)

# Test case 3: Single node
head3 = create_list([1])
print("\nOriginal list:", end=" ")
print_list(head3)
head3 = remove_nth_from_end(head3, 1)
print("After removing 1st from end:", end=" ")
print_list(head3)
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

function removeNthFromEnd(head, n) {
    // Use dummy node to handle edge cases uniformly
    const dummy = new Node(0);
    dummy.next = head;

    let fast = dummy;
    let slow = dummy;

    // Move fast n+1 steps ahead so slow stops before node to delete
    for (let i = 0; i <= n; i++) {
        if (!fast) return head; // n is larger than list length
        fast = fast.next;
    }

    // Move both pointers together
    while (fast) {
        slow = slow.next;
        fast = fast.next;
    }

    // Delete the nth node from end
    slow.next = slow.next.next;

    return dummy.next;
}

// Helper function to create linked list
function createList(arr) {
    if (arr.length === 0) return null;
    const head = new Node(arr[0]);
    let curr = head;
    for (let i = 1; i < arr.length; i++) {
        curr.next = new Node(arr[i]);
        curr = curr.next;
    }
    return head;
}

// Helper function to print list
function printList(head) {
    const result = [];
    while (head) {
        result.push(head.data);
        head = head.next;
    }
    console.log(result.length ? result.join(" → ") : "null");
}

// Test case 1: Remove 2nd from end
let head1 = createList([1, 2, 3, 4, 5]);
console.log("Original list:");
printList(head1);
head1 = removeNthFromEnd(head1, 2);
console.log("After removing 2nd from end:");
printList(head1);

// Test case 2: Remove head (5th from end)
let head2 = createList([1, 2, 3, 4, 5]);
console.log("\nOriginal list:");
printList(head2);
head2 = removeNthFromEnd(head2, 5);
console.log("After removing 5th from end:");
printList(head2);

// Test case 3: Single node
let head3 = createList([1]);
console.log("\nOriginal list:");
printList(head3);
head3 = removeNthFromEnd(head3, 1);
console.log("After removing 1st from end:");
printList(head3);
```
  </Tab>
</Tabs>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n) <TranslatedText en="where n is the number of nodes" bn="যেখানে n হল নোডের সংখ্যা" />

**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

## <TranslatedText en="Approach 2: Without Dummy Node" bn="পদ্ধতি ২: ডামি নোড ছাড়া" />

<TranslatedText
  en="Same two-pointer approach but with explicit handling for removing the head node."
  bn="একই টু-পয়েন্টার পদ্ধতি কিন্তু হেড নোড সরানোর জন্য স্পষ্ট হ্যান্ডলিং সহ।"
/>

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
Node* removeNthFromEndNoSpace(Node* head, int n) {
    Node* fast = head;
    Node* slow = head;

    // Move fast n steps ahead
    for (int i = 0; i < n; i++) {
        if (!fast) return head; // n is larger than list length
        fast = fast->next;
    }

    // If fast is null, we need to remove the head
    if (!fast) {
        Node* newHead = head->next;
        delete head;
        return newHead;
    }

    // Move both pointers until fast reaches last node
    while (fast->next) {
        slow = slow->next;
        fast = fast->next;
    }

    // Delete the nth node from end
    Node* toDelete = slow->next;
    slow->next = slow->next->next;
    delete toDelete;

    return head;
}
```
  </Tab>
  <Tab value="Python">
```python
def remove_nth_from_end_no_dummy(head, n):
    fast = head
    slow = head

    # Move fast n steps ahead
    for i in range(n):
        if not fast:
            return head  # n is larger than list length
        fast = fast.next

    # If fast is None, we need to remove the head
    if not fast:
        return head.next

    # Move both pointers until fast reaches last node
    while fast.next:
        slow = slow.next
        fast = fast.next

    # Delete the nth node from end
    slow.next = slow.next.next

    return head
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function removeNthFromEndNoDummy(head, n) {
    let fast = head;
    let slow = head;

    // Move fast n steps ahead
    for (let i = 0; i < n; i++) {
        if (!fast) return head; // n is larger than list length
        fast = fast.next;
    }

    // If fast is null, we need to remove the head
    if (!fast) {
        return head.next;
    }

    // Move both pointers until fast reaches last node
    while (fast.next) {
        slow = slow.next;
        fast = fast.next;
    }

    // Delete the nth node from end
    slow.next = slow.next.next;

    return head;
}
```
  </Tab>
</Tabs>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n)

**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(1)

## <TranslatedText en="How It Works" bn="এটি কীভাবে কাজ করে" />

<TranslatedText
  en="The algorithm uses the two-pointer technique with a fixed gap:"
  bn="অ্যালগরিদম একটি নির্দিষ্ট ব্যবধান সহ টু-পয়েন্টার কৌশল ব্যবহার করে:"
/>

```
Example: Remove 2nd node from end (n=2) in list 1 → 2 → 3 → 4 → 5

Step 1: Create dummy and position pointers
        dummy → 1 → 2 → 3 → 4 → 5
        ^
        s,f

Step 2: Move fast n+1 (3) steps ahead
        dummy → 1 → 2 → 3 → 4 → 5
        ^           ^
        s           f

Step 3: Move both together until fast reaches end
        dummy → 1 → 2 → 3 → 4 → 5
                    ^           ^
                    s           f

Step 4: slow is now before the node to delete (4)
        Remove slow.next:
        dummy → 1 → 2 → 3 → 5
                    ^
                    s

Result: 1 → 2 → 3 → 5
```

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Dummy node advantage</strong>: Eliminates special case handling for removing head node</li>
        <li><strong>Gap of n+1</strong>: Fast pointer moves n+1 steps so slow stops BEFORE the node to delete</li>
        <li><strong>Single traversal</strong>: Only one pass through the list is needed</li>
        <li><strong>Edge case handling</strong>: Works correctly for removing head, tail, or middle nodes</li>
        <li><strong>Memory management</strong>: Remember to delete the removed node (in C++)</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>ডামি নোড সুবিধা</strong>: হেড নোড সরানোর জন্য বিশেষ কেস হ্যান্ডলিং দূর করে</li>
        <li><strong>n+1 ব্যবধান</strong>: দ্রুত পয়েন্টার n+1 ধাপ চলে যাতে ধীর মুছে ফেলার নোডের আগে থামে</li>
        <li><strong>একক ট্রাভার্সাল</strong>: লিস্টের মাধ্যমে শুধুমাত্র একটি পাস প্রয়োজন</li>
        <li><strong>এজ কেস হ্যান্ডলিং</strong>: হেড, টেইল বা মধ্যম নোড সরানোর জন্য সঠিকভাবে কাজ করে</li>
        <li><strong>মেমরি ম্যানেজমেন্ট</strong>: সরানো নোড মুছে ফেলতে মনে রাখবেন (C++ এ)</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Edge Cases to Consider" bn="বিবেচনা করার জন্য এজ কেস" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Empty list</strong>: Return null</li>
        <li><strong>Single node</strong>: Removing it returns null</li>
        <li><strong>Remove head</strong>: When n equals list length</li>
        <li><strong>Remove tail</strong>: When n = 1</li>
        <li><strong>n greater than length</strong>: Should return original list or handle gracefully</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>খালি লিস্ট</strong>: null ফেরত দিন</li>
        <li><strong>একক নোড</strong>: এটি সরালে null ফেরত আসে</li>
        <li><strong>হেড সরান</strong>: যখন n লিস্ট দৈর্ঘ্যের সমান</li>
        <li><strong>টেইল সরান</strong>: যখন n = 1</li>
        <li><strong>দৈর্ঘ্যের চেয়ে বড় n</strong>: মূল লিস্ট ফেরত দিন বা সুন্দরভাবে হ্যান্ডেল করুন</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Clarify constraints</strong>: Ask if n is guaranteed to be valid</li>
        <li><strong>Mention the one-pass requirement</strong>: Emphasize the efficiency of the two-pointer approach</li>
        <li><strong>Explain dummy node benefits</strong>: Simplifies code by avoiding special cases</li>
        <li><strong>Discuss trade-offs</strong>: Dummy node uses O(1) extra space but makes code cleaner</li>
        <li><strong>Walk through edge cases</strong>: Especially removing the head node</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>সীমাবদ্ধতা স্পষ্ট করুন</strong>: জিজ্ঞাসা করুন n বৈধ হওয়ার গ্যারান্টি আছে কিনা</li>
        <li><strong>এক-পাস প্রয়োজনীয়তা উল্লেখ করুন</strong>: টু-পয়েন্টার পদ্ধতির দক্ষতা জোর দিন</li>
        <li><strong>ডামি নোড সুবিধা ব্যাখ্যা করুন</strong>: বিশেষ কেস এড়িয়ে কোড সরল করে</li>
        <li><strong>ট্রেড-অফ আলোচনা করুন</strong>: ডামি নোড O(1) অতিরিক্ত স্থান ব্যবহার করে কিন্তু কোড পরিষ্কার করে</li>
        <li><strong>এজ কেস দিয়ে হাঁটুন</strong>: বিশেষ করে হেড নোড সরানো</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Common Mistakes to Avoid" bn="এড়ানোর জন্য সাধারণ ভুল" />

<TranslatedText
  en={
    <>
      <ul>
        <li>Moving fast only n steps instead of n+1 (causes off-by-one error)</li>
        <li>Not handling the case when n equals list length (removing head)</li>
        <li>Forgetting to delete the removed node in C++ (memory leak)</li>
        <li>Not using dummy node and having messy special case code</li>
        <li>Not checking if fast becomes null before accessing fast.next</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li>দ্রুতকে n+1 এর পরিবর্তে শুধুমাত্র n ধাপ সরানো (অফ-বাই-ওয়ান ত্রুটি ঘটায়)</li>
        <li>n লিস্ট দৈর্ঘ্যের সমান হলে হ্যান্ডেল না করা (হেড সরানো)</li>
        <li>C++ এ সরানো নোড মুছতে ভুলে যাওয়া (মেমরি লিক)</li>
        <li>ডামি নোড ব্যবহার না করা এবং জটিল বিশেষ কেস কোড থাকা</li>
        <li>fast.next অ্যাক্সেস করার আগে fast null হয়ে গেছে কিনা চেক না করা</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Related Problems" bn="সম্পর্কিত সমস্যা" />

- Find the middle element of a linked list
- Find the third node from the end
- Remove duplicates from a linked list
- Delete a node in a linked list (when node reference is given)
- Reorder list (involves finding middle and reversing)

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

<TranslatedText
  en={
    <>
      <ul>
        <li>Two-pointer technique with fixed gap solves many linked list problems</li>
        <li>Dummy node simplifies edge case handling significantly</li>
        <li>Gap of n+1 ensures slow pointer stops before the target node</li>
        <li>O(n) time with O(1) space - optimal solution</li>
        <li>This pattern is fundamental for linked list manipulation</li>
        <li>Always consider whether to use dummy node for cleaner code</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li>নির্দিষ্ট ব্যবধান সহ টু-পয়েন্টার কৌশল অনেক লিঙ্কড লিস্ট সমস্যা সমাধান করে</li>
        <li>ডামি নোড এজ কেস হ্যান্ডলিং উল্লেখযোগ্যভাবে সরল করে</li>
        <li>n+1 ব্যবধান নিশ্চিত করে যে ধীর পয়েন্টার লক্ষ্য নোডের আগে থামে</li>
        <li>O(n) সময় O(1) স্থান সহ - সর্বোত্তম সমাধান</li>
        <li>এই প্যাটার্ন লিঙ্কড লিস্ট ম্যানিপুলেশনের জন্য মৌলিক</li>
        <li>সবসময় বিবেচনা করুন পরিষ্কার কোডের জন্য ডামি নোড ব্যবহার করবেন কিনা</li>
      </ul>
    </>
  }
/>
