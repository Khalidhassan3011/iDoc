---
title: Reverse a Linked List
description: How to reverse a singly linked list using iteration and recursion
---

## Problem Statement

Write a program to reverse a singly linked list. Implement both iterative and recursive approaches.

## Examples

### Example 1
```
Input: 1 -> 2 -> 3 -> 4 -> 5 -> null
Output: 5 -> 4 -> 3 -> 2 -> 1 -> null
```

### Example 2
```
Input: 1 -> 2 -> null
Output: 2 -> 1 -> null
```

### Example 3
```
Input: 1 -> null
Output: 1 -> null
```

## Linked List Node Definition

```dart
class Node {
  int data;
  Node? next;

  Node(this.data, [this.next]);
}
```

## Solution

### Approach 1: Iterative (Optimal)

Reverse the list by changing the next pointers iteratively.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

```dart
class Node {
  int data;
  Node? next;

  Node(this.data, [this.next]);
}

Node? reverseListIterative(Node? head) {
  Node? prev = null;
  Node? current = head;
  Node? next;

  while (current != null) {
    // Store next node
    next = current.next;

    // Reverse the link
    current.next = prev;

    // Move prev and current one step forward
    prev = current;
    current = next;
  }

  return prev; // New head
}

void printList(Node? head) {
  Node? current = head;
  while (current != null) {
    print('${current.data} -> ', end: '');
    current = current.next;
  }
  print('null');
}

void print(String text, {String end = '\n'}) {
  stdout.write(text + end);
}

void main() {
  // Create list: 1 -> 2 -> 3 -> 4 -> 5
  Node head = Node(1, Node(2, Node(3, Node(4, Node(5)))));

  print('Original list:');
  printList(head);

  Node? reversed = reverseListIterative(head);

  print('\nReversed list:');
  printList(reversed);
}
```

### Approach 2: Recursive

Elegant recursive solution.

**Time Complexity:** O(n)
**Space Complexity:** O(n) due to recursion stack

```dart
Node? reverseListRecursive(Node? head) {
  // Base cases
  if (head == null || head.next == null) {
    return head;
  }

  // Reverse the rest of the list
  Node? newHead = reverseListRecursive(head.next);

  // Make the next node point back to current
  head.next!.next = head;

  // Remove the link from current to next
  head.next = null;

  return newHead;
}

void main() {
  Node head = Node(1, Node(2, Node(3, Node(4, Node(5)))));

  print('Original list:');
  printList(head);

  Node? reversed = reverseListRecursive(head);

  print('\nReversed list:');
  printList(reversed);
}
```

### Approach 3: Using Stack

Store nodes in a stack and rebuild the list.

**Time Complexity:** O(n)
**Space Complexity:** O(n)

```dart
Node? reverseListStack(Node? head) {
  if (head == null) return null;

  List<Node> stack = [];
  Node? current = head;

  // Push all nodes to stack
  while (current != null) {
    stack.add(current);
    current = current.next;
  }

  // Pop from stack and rebuild
  Node? newHead = stack.removeLast();
  current = newHead;

  while (stack.isNotEmpty) {
    current!.next = stack.removeLast();
    current = current.next;
  }

  current!.next = null;

  return newHead;
}

void main() {
  Node head = Node(1, Node(2, Node(3, Node(4, Node(5)))));

  print('Original list:');
  printList(head);

  Node? reversed = reverseListStack(head);

  print('\nReversed list:');
  printList(reversed);
}
```

### Approach 4: Tail Recursive

Tail-recursive version that can be optimized by compiler.

**Time Complexity:** O(n)
**Space Complexity:** O(n) for recursion stack

```dart
Node? reverseListTailRecursive(Node? head, [Node? prev]) {
  if (head == null) {
    return prev;
  }

  Node? next = head.next;
  head.next = prev;

  return reverseListTailRecursive(next, head);
}

void main() {
  Node head = Node(1, Node(2, Node(3, Node(4, Node(5)))));

  print('Original list:');
  printList(head);

  Node? reversed = reverseListTailRecursive(head);

  print('\nReversed list:');
  printList(reversed);
}
```

### Approach 5: Reverse in Groups

Reverse the list in groups of k nodes.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

```dart
Node? reverseInGroups(Node? head, int k) {
  if (head == null) return null;

  Node? current = head;
  Node? prev = null;
  Node? next;
  int count = 0;

  // Reverse first k nodes
  while (current != null && count < k) {
    next = current.next;
    current.next = prev;
    prev = current;
    current = next;
    count++;
  }

  // Recursively reverse the rest
  if (next != null) {
    head.next = reverseInGroups(next, k);
  }

  return prev;
}

void main() {
  Node head = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8))))))));

  print('Original list:');
  printList(head);

  Node? reversed = reverseInGroups(head, 3);

  print('\nReversed in groups of 3:');
  printList(reversed);
}
```

### Approach 6: Complete LinkedList Class

Full implementation with reverse method.

```dart
class LinkedList {
  Node? head;

  void add(int data) {
    if (head == null) {
      head = Node(data);
      return;
    }

    Node? current = head;
    while (current!.next != null) {
      current = current.next;
    }
    current.next = Node(data);
  }

  void reverse() {
    Node? prev = null;
    Node? current = head;
    Node? next;

    while (current != null) {
      next = current.next;
      current.next = prev;
      prev = current;
      current = next;
    }

    head = prev;
  }

  void display() {
    Node? current = head;
    while (current != null) {
      stdout.write('${current.data} -> ');
      current = current.next;
    }
    print('null');
  }

  int? get(int index) {
    Node? current = head;
    int count = 0;

    while (current != null) {
      if (count == index) {
        return current.data;
      }
      count++;
      current = current.next;
    }

    return null;
  }

  int get length {
    int count = 0;
    Node? current = head;

    while (current != null) {
      count++;
      current = current.next;
    }

    return count;
  }
}

void main() {
  LinkedList list = LinkedList();

  list.add(1);
  list.add(2);
  list.add(3);
  list.add(4);
  list.add(5);

  print('Original list:');
  list.display();
  print('Length: ${list.length}');

  list.reverse();

  print('\nReversed list:');
  list.display();

  print('\nElement at index 2: ${list.get(2)}');
}
```

## Visualization

### Iterative Reversal Process:

```
Initial: 1 -> 2 -> 3 -> 4 -> 5 -> null
         ↑
        head

Step 1:  null <- 1    2 -> 3 -> 4 -> 5 -> null
               prev  curr

Step 2:  null <- 1 <- 2    3 -> 4 -> 5 -> null
                     prev  curr

Step 3:  null <- 1 <- 2 <- 3    4 -> 5 -> null
                          prev  curr

Step 4:  null <- 1 <- 2 <- 3 <- 4    5 -> null
                               prev  curr

Step 5:  null <- 1 <- 2 <- 3 <- 4 <- 5    null
                                    prev  curr

Result:  5 -> 4 -> 3 -> 2 -> 1 -> null
         ↑
       newHead
```

### Recursive Reversal:

```
reverseList(1 -> 2 -> 3 -> 4 -> 5)
    reverseList(2 -> 3 -> 4 -> 5)
        reverseList(3 -> 4 -> 5)
            reverseList(4 -> 5)
                reverseList(5) → returns 5
                5 -> 4 -> null
            returns 5
            5 -> 4 -> 3 -> null
        returns 5
        5 -> 4 -> 3 -> 2 -> null
    returns 5
    5 -> 4 -> 3 -> 2 -> 1 -> null
returns 5
```

## Comparison of Approaches

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Iterative | O(n) | O(1) | Optimal, no recursion | More code |
| Recursive | O(n) | O(n) | Elegant, clean | Stack space |
| Stack | O(n) | O(n) | Easy to understand | Extra space |
| Tail Recursive | O(n) | O(n) | Cleaner recursion | Stack space |
| In Groups | O(n) | O(1) | Flexible | More complex |

## Key Points

1. **Iterative Preferred**: O(1) space, no stack overflow risk
2. **Three Pointers**: prev, current, next needed for iterative
3. **Recursive Base Case**: Single node or null
4. **In-Place**: Both methods modify the original list
5. **Return New Head**: The old tail becomes the new head

## Common Pitfalls

- Forgetting to save the next node before changing pointers
- Not updating the head pointer
- Not handling empty list or single node
- Creating a cycle by not setting the old head's next to null
- Stack overflow with recursive approach on very long lists

## Edge Cases

```dart
void testEdgeCases() {
  // Empty list
  Node? empty = null;
  print('Empty: ${reverseListIterative(empty)}');

  // Single node
  Node single = Node(1);
  print('Single: ${reverseListIterative(single)?.data}');

  // Two nodes
  Node two = Node(1, Node(2));
  var reversed = reverseListIterative(two);
  print('Two nodes: ${reversed?.data} -> ${reversed?.next?.data}');
}
```

## Test Cases

```dart
void testReverseList() {
  // Test 1: Normal list
  Node head1 = Node(1, Node(2, Node(3, Node(4, Node(5)))));
  Node? rev1 = reverseListIterative(head1);
  assert(rev1?.data == 5);
  assert(rev1?.next?.data == 4);

  // Test 2: Single element
  Node head2 = Node(1);
  Node? rev2 = reverseListIterative(head2);
  assert(rev2?.data == 1);
  assert(rev2?.next == null);

  // Test 3: Two elements
  Node head3 = Node(1, Node(2));
  Node? rev3 = reverseListIterative(head3);
  assert(rev3?.data == 2);
  assert(rev3?.next?.data == 1);

  // Test 4: Empty list
  Node? rev4 = reverseListIterative(null);
  assert(rev4 == null);

  print('All tests passed!');
}
```

## Applications

- Undo/Redo functionality
- Browser back button
- Reversing a path
- Palindrome checking
- Expression evaluation

## Performance

```dart
import 'dart:io';

void benchmark() {
  List<int> sizes = [100, 1000, 10000];

  for (int size in sizes) {
    // Create list
    Node? head = Node(0);
    Node? current = head;
    for (int i = 1; i < size; i++) {
      current!.next = Node(i);
      current = current.next;
    }

    // Benchmark iterative
    Stopwatch sw1 = Stopwatch()..start();
    reverseListIterative(head);
    sw1.stop();

    // Recreate list for recursive test
    head = Node(0);
    current = head;
    for (int i = 1; i < size; i++) {
      current!.next = Node(i);
      current = current.next;
    }

    // Benchmark recursive
    Stopwatch sw2 = Stopwatch()..start();
    reverseListRecursive(head);
    sw2.stop();

    print('Size: $size');
    print('  Iterative: ${sw1.elapsedMicroseconds} μs');
    print('  Recursive: ${sw2.elapsedMicroseconds} μs\n');
  }
}
```

## Related Problems

- Reverse linked list in groups of k
- Reverse alternate k nodes
- Reverse a doubly linked list
- Reverse only odd positioned nodes
- Palindrome linked list (requires reversal)

## Reference

- [GeeksforGeeks - Reverse Linked List](https://www.geeksforgeeks.org/reverse-a-linked-list/)
- [Java67 - Reverse Singly Linked List](http://www.java67.com/2016/07/how-to-reverse-singly-linked-list-in-java-example.html)
- [JavaRevisited - Iteration and Recursion](http://javarevisited.blogspot.sg/2017/03/how-to-reverse-linked-list-in-java-using-iteration-and-recursion.html)
