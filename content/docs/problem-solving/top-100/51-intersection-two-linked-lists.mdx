---
title: 51. Intersection of Two Linked Lists
description: Find the node at which two singly linked lists intersect
---

## Problem Statement

Given two singly linked lists, find the node at which the two lists intersect. If the two linked lists have no intersection, return null.

## Examples

### Example 1
```
List A: 1 -> 2 -> 3 \
                      6 -> 7 -> 8
List B: 4 -> 5 ------/

Intersection at node with value 6
```

### Example 2
```
List A: 1 -> 2 -> 3 -> 4
List B: 5 -> 6 -> 7

No intersection, return null
```

### Example 3
```
List A: 1 \
          3 -> 4 -> 5
List B: 2 /

Intersection at node with value 3
```

## Solution

### Approach 1: Using Length Difference (Optimal)

Calculate lengths, align the lists, then find intersection.

**Time Complexity:** O(m + n)
**Space Complexity:** O(1)

```dart
class Node {
  int data;
  Node? next;

  Node(this.data, [this.next]);
}

int getLength(Node? head) {
  int length = 0;
  Node? current = head;

  while (current != null) {
    length++;
    current = current.next;
  }

  return length;
}

Node? getIntersection(Node? head1, Node? head2) {
  if (head1 == null || head2 == null) return null;

  // Get lengths
  int len1 = getLength(head1);
  int len2 = getLength(head2);

  // Align the lists
  Node? longer = len1 > len2 ? head1 : head2;
  Node? shorter = len1 > len2 ? head2 : head1;
  int diff = (len1 - len2).abs();

  // Move longer list pointer forward by diff
  for (int i = 0; i < diff; i++) {
    longer = longer!.next;
  }

  // Find intersection
  while (longer != null && shorter != null) {
    if (identical(longer, shorter)) {
      return longer;
    }
    longer = longer.next;
    shorter = shorter.next;
  }

  return null;
}

void main() {
  // Create intersection
  Node common = Node(6, Node(7, Node(8)));

  // List A: 1 -> 2 -> 3 -> common
  Node head1 = Node(1, Node(2, Node(3, common)));

  // List B: 4 -> 5 -> common
  Node head2 = Node(4, Node(5, common));

  Node? intersection = getIntersection(head1, head2);

  if (intersection != null) {
    print('Lists intersect at node with value ${intersection.data}');
  } else {
    print('No intersection');
  }
}
```

### Approach 2: Using HashSet

Store nodes from one list in a set, then check the other list.

**Time Complexity:** O(m + n)
**Space Complexity:** O(m) or O(n)

```dart
Node? getIntersectionHashSet(Node? head1, Node? head2) {
  if (head1 == null || head2 == null) return null;

  Set<Node> visited = {};

  // Add all nodes from first list to set
  Node? current = head1;
  while (current != null) {
    visited.add(current);
    current = current.next;
  }

  // Check second list for intersection
  current = head2;
  while (current != null) {
    if (visited.contains(current)) {
      return current;
    }
    current = current.next;
  }

  return null;
}

void main() {
  Node common = Node(6, Node(7, Node(8)));
  Node head1 = Node(1, Node(2, Node(3, common)));
  Node head2 = Node(4, Node(5, common)));

  Node? intersection = getIntersectionHashSet(head1, head2);

  if (intersection != null) {
    print('Lists intersect at node with value ${intersection.data}');
  } else {
    print('No intersection');
  }
}
```

### Approach 3: Two Pointers (Elegant)

Move pointers through both lists, swapping heads when reaching end.

**Time Complexity:** O(m + n)
**Space Complexity:** O(1)

```dart
Node? getIntersectionTwoPointers(Node? head1, Node? head2) {
  if (head1 == null || head2 == null) return null;

  Node? p1 = head1;
  Node? p2 = head2;

  // Traverse both lists
  // When a pointer reaches end, redirect to other list's head
  while (p1 != p2) {
    p1 = (p1 == null) ? head2 : p1.next;
    p2 = (p2 == null) ? head1 : p2.next;
  }

  return p1; // Will be null if no intersection
}

void main() {
  Node common = Node(6, Node(7, Node(8)));
  Node head1 = Node(1, Node(2, Node(3, common)));
  Node head2 = Node(4, Node(5, common));

  Node? intersection = getIntersectionTwoPointers(head1, head2);

  if (intersection != null) {
    print('Lists intersect at node with value ${intersection.data}');
  } else {
    print('No intersection');
  }
}
```

### Approach 4: Using Tail Comparison

Check if lists have the same tail (last node).

**Time Complexity:** O(m + n)
**Space Complexity:** O(1)

```dart
class IntersectionResult {
  bool hasIntersection;
  Node? intersectionNode;

  IntersectionResult(this.hasIntersection, [this.intersectionNode]);
}

Node? getTail(Node? head) {
  if (head == null) return null;

  Node? current = head;
  while (current!.next != null) {
    current = current.next;
  }

  return current;
}

IntersectionResult checkAndGetIntersection(Node? head1, Node? head2) {
  if (head1 == null || head2 == null) {
    return IntersectionResult(false);
  }

  // Get tails
  Node? tail1 = getTail(head1);
  Node? tail2 = getTail(head2);

  // If tails are different, no intersection
  if (!identical(tail1, tail2)) {
    return IntersectionResult(false);
  }

  // Find the actual intersection point
  Node? intersection = getIntersection(head1, head2);

  return IntersectionResult(true, intersection);
}

void main() {
  Node common = Node(6, Node(7, Node(8)));
  Node head1 = Node(1, Node(2, Node(3, common)));
  Node head2 = Node(4, Node(5, common));

  var result = checkAndGetIntersection(head1, head2);

  if (result.hasIntersection) {
    print('Lists intersect at node with value ${result.intersectionNode?.data}');
  } else {
    print('No intersection');
  }
}
```

### Approach 5: Mark Visited Nodes (Destructive)

Temporarily modify nodes to mark visited (not recommended for production).

**Time Complexity:** O(m + n)
**Space Complexity:** O(1)

```dart
Node? getIntersectionMarking(Node? head1, Node? head2) {
  if (head1 == null || head2 == null) return null;

  // Mark all nodes in first list by negating data
  Node? current = head1;
  while (current != null) {
    current.data = -current.data;
    current = current.next;
  }

  // Find first marked node in second list
  current = head2;
  Node? intersection;

  while (current != null) {
    if (current.data < 0) {
      intersection = current;
      break;
    }
    current = current.next;
  }

  // Restore first list
  current = head1;
  while (current != null) {
    current.data = -current.data;
    current = current.next;
  }

  return intersection;
}

void main() {
  Node common = Node(6, Node(7, Node(8)));
  Node head1 = Node(1, Node(2, Node(3, common)));
  Node head2 = Node(4, Node(5, common));

  Node? intersection = getIntersectionMarking(head1, head2);

  if (intersection != null) {
    print('Lists intersect at node with value ${intersection.data}');
  } else {
    print('No intersection');
  }
}
```

## Visualization

### Two Pointer Approach:

```
List A: 1 -> 2 -> 3 \
                      6 -> 7 -> 8 -> null
List B: 4 -> 5 ------/

Length A = 6, Length B = 5

Step 1: p1 = 1, p2 = 4
Step 2: p1 = 2, p2 = 5
Step 3: p1 = 3, p2 = 6
Step 4: p1 = 6, p2 = 7
Step 5: p1 = 7, p2 = 8
Step 6: p1 = 8, p2 = null
Step 7: p1 = null, p2 = 1 (switch to head1)
Step 8: p1 = 4 (switch to head2), p2 = 2
Step 9: p1 = 5, p2 = 3
Step 10: p1 = 6, p2 = 6 ‚Üê Intersection found!
```

## Comparison of Approaches

| Approach | Time | Space | Pros | Cons |
|----------|------|-------|------|------|
| Length Difference | O(m+n) | O(1) | Optimal, clear | Requires 3 passes |
| HashSet | O(m+n) | O(m) | Simple | Extra space |
| Two Pointers | O(m+n) | O(1) | Elegant, optimal | Subtle logic |
| Tail Comparison | O(m+n) | O(1) | Quick check | Still needs full search |
| Marking | O(m+n) | O(1) | No extra space | Modifies data |

## Key Points

1. **Identity Check**: Use `identical()` in Dart, not `==`
2. **Same Tail**: If lists intersect, they share the same tail
3. **No Cycle**: Assumes lists don't contain cycles
4. **Physical Node**: Intersection is physical node, not value
5. **Two Pointer Trick**: Both traverse same total distance

## Common Pitfalls

- Comparing values instead of node identity
- Not handling different length lists
- Not handling null lists
- Modifying the original lists unintentionally
- Assuming intersection means same values

## Test Cases

```dart
void testIntersection() {
  // Test 1: With intersection
  Node common1 = Node(6, Node(7, Node(8)));
  Node head1a = Node(1, Node(2, Node(3, common1)));
  Node head1b = Node(4, Node(5, common1));
  assert(getIntersection(head1a, head1b)?.data == 6);

  // Test 2: No intersection
  Node head2a = Node(1, Node(2, Node(3)));
  Node head2b = Node(4, Node(5, Node(6)));
  assert(getIntersection(head2a, head2b) == null);

  // Test 3: Intersection at head
  Node common3 = Node(1, Node(2, Node(3)));
  assert(identical(getIntersection(common3, common3), common3));

  // Test 4: One list empty
  Node head4 = Node(1, Node(2));
  assert(getIntersection(head4, null) == null);

  // Test 5: Different lengths
  Node common5 = Node(5);
  Node head5a = Node(1, Node(2, Node(3, Node(4, common5))));
  Node head5b = Node(9, common5);
  assert(getIntersection(head5a, head5b)?.data == 5);

  print('All tests passed!');
}
```

## Why Two Pointer Works

Both pointers traverse the same total distance:
- Length of A + Length of B
- When they meet, it's either at intersection or both are null

```
If lengths are m and n:
Pointer 1: m steps (list A) + (n - k) steps (list B) = m + n - k
Pointer 2: n steps (list B) + (m - k) steps (list A) = m + n - k

Where k is the length from intersection to end
They meet at the intersection!
```

## Applications

- Detecting shared memory in data structures
- Finding common ancestors
- Merge points in version control
- Dependency resolution
- Graph cycle detection variations

## Related Problems

- Linked list cycle detection
- Merge two sorted lists
- Clone list with random pointer
- Find the starting point of a cycle

## Reference

[LeetCode - Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/solution/)
