---
title: 102. AVL Tree
description: Understanding and implementing AVL Tree with rotations
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="AVL Tree" bn="AVL ট্রি" />

<TranslatedText en="AVL Tree is a self-balancing BST where the height difference between left and right subtrees is at most 1." bn="AVL ট্রি হল একটি স্ব-ভারসাম্যপূর্ণ BST যেখানে বাম এবং ডান সাবট্রির উচ্চতার পার্থক্য সর্বোচ্চ 1।" />

## <TranslatedText en="AVL Tree Properties" bn="AVL ট্রি বৈশিষ্ট্য" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>Balance Factor:</strong> Height(left subtree) - Height(right subtree) must be -1, 0, or 1</li>
        <li><strong>Height:</strong> Always O(log n) for n nodes</li>
        <li><strong>Rotations:</strong> Uses 4 types of rotations to maintain balance</li>
        <li><strong>Performance:</strong> All operations (search, insert, delete) are O(log n)</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>ভারসাম্য ফ্যাক্টর:</strong> উচ্চতা(বাম সাবট্রি) - উচ্চতা(ডান সাবট্রি) অবশ্যই -1, 0, বা 1 হতে হবে</li>
        <li><strong>উচ্চতা:</strong> n নোডের জন্য সবসময় O(log n)</li>
        <li><strong>ঘূর্ণন:</strong> ভারসাম্য বজায় রাখতে 4 ধরনের ঘূর্ণন ব্যবহার করে</li>
        <li><strong>পারফরম্যান্স:</strong> সব অপারেশন (সার্চ, ইনসার্ট, ডিলিট) O(log n)</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Types of Rotations" bn="ঘূর্ণনের ধরন" />

<TranslatedText
  en={
    <>
      <ol>
        <li><strong>Left Rotation (LL):</strong> When right subtree is heavier</li>
        <li><strong>Right Rotation (RR):</strong> When left subtree is heavier</li>
        <li><strong>Left-Right Rotation (LR):</strong> Left rotation followed by right rotation</li>
        <li><strong>Right-Left Rotation (RL):</strong> Right rotation followed by left rotation</li>
      </ol>
    </>
  }
  bn={
    <>
      <ol>
        <li><strong>বাম ঘূর্ণন (LL):</strong> যখন ডান সাবট্রি ভারী</li>
        <li><strong>ডান ঘূর্ণন (RR):</strong> যখন বাম সাবট্রি ভারী</li>
        <li><strong>বাম-ডান ঘূর্ণন (LR):</strong> বাম ঘূর্ণন এবং তারপর ডান ঘূর্ণন</li>
        <li><strong>ডান-বাম ঘূর্ণন (RL):</strong> ডান ঘূর্ণন এবং তারপর বাম ঘূর্ণন</li>
      </ol>
    </>
  }
/>

## <TranslatedText en="Implementation" bn="বাস্তবায়ন" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

struct AVLNode {
    int val;
    AVLNode* left;
    AVLNode* right;
    int height;
    AVLNode(int x) : val(x), left(nullptr), right(nullptr), height(1) {}
};

int getHeight(AVLNode* node) {
    return node ? node->height : 0;
}

int getBalance(AVLNode* node) {
    return node ? getHeight(node->left) - getHeight(node->right) : 0;
}

AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

AVLNode* insert(AVLNode* node, int val) {
    if (!node) return new AVLNode(val);

    if (val < node->val)
        node->left = insert(node->left, val);
    else if (val > node->val)
        node->right = insert(node->right, val);
    else
        return node;

    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    int balance = getBalance(node);

    // Left Left
    if (balance > 1 && val < node->left->val)
        return rightRotate(node);

    // Right Right
    if (balance < -1 && val > node->right->val)
        return leftRotate(node);

    // Left Right
    if (balance > 1 && val > node->left->val) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }

    // Right Left
    if (balance < -1 && val < node->right->val) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

void inorder(AVLNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}

int main() {
    AVLNode* root = nullptr;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 30);
    root = insert(root, 40);
    root = insert(root, 50);
    root = insert(root, 25);

    cout << "Inorder traversal of AVL tree: ";
    inorder(root);
    cout << endl;

    return 0;
}
```

**Output:**
```
Inorder traversal of AVL tree: 10 20 25 30 40 50
```
  </Tab>
  <Tab value="Python">
```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1

def get_height(node):
    return node.height if node else 0

def get_balance(node):
    return get_height(node.left) - get_height(node.right) if node else 0

def right_rotate(y):
    x = y.left
    T2 = x.right

    x.right = y
    y.left = T2

    y.height = max(get_height(y.left), get_height(y.right)) + 1
    x.height = max(get_height(x.left), get_height(x.right)) + 1

    return x

def left_rotate(x):
    y = x.right
    T2 = y.left

    y.left = x
    x.right = T2

    x.height = max(get_height(x.left), get_height(x.right)) + 1
    y.height = max(get_height(y.left), get_height(y.right)) + 1

    return y

def insert(node, val):
    if not node:
        return AVLNode(val)

    if val < node.val:
        node.left = insert(node.left, val)
    elif val > node.val:
        node.right = insert(node.right, val)
    else:
        return node

    node.height = 1 + max(get_height(node.left), get_height(node.right))

    balance = get_balance(node)

    # Left Left
    if balance > 1 and val < node.left.val:
        return right_rotate(node)

    # Right Right
    if balance < -1 and val > node.right.val:
        return left_rotate(node)

    # Left Right
    if balance > 1 and val > node.left.val:
        node.left = left_rotate(node.left)
        return right_rotate(node)

    # Right Left
    if balance < -1 and val < node.right.val:
        node.right = right_rotate(node.right)
        return left_rotate(node)

    return node

def inorder(root):
    if not root:
        return
    inorder(root.left)
    print(root.val, end=" ")
    inorder(root.right)

root = None
root = insert(root, 10)
root = insert(root, 20)
root = insert(root, 30)
root = insert(root, 40)
root = insert(root, 50)
root = insert(root, 25)

print("Inorder traversal of AVL tree:", end=" ")
inorder(root)
print()
```

**Output:**
```
Inorder traversal of AVL tree: 10 20 25 30 40 50
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class AVLNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
        this.height = 1;
    }
}

function getHeight(node) {
    return node ? node.height : 0;
}

function getBalance(node) {
    return node ? getHeight(node.left) - getHeight(node.right) : 0;
}

function rightRotate(y) {
    const x = y.left;
    const T2 = x.right;

    x.right = y;
    y.left = T2;

    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;

    return x;
}

function leftRotate(x) {
    const y = x.right;
    const T2 = y.left;

    y.left = x;
    x.right = T2;

    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;

    return y;
}

function insert(node, val) {
    if (!node) return new AVLNode(val);

    if (val < node.val)
        node.left = insert(node.left, val);
    else if (val > node.val)
        node.right = insert(node.right, val);
    else
        return node;

    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));

    const balance = getBalance(node);

    // Left Left
    if (balance > 1 && val < node.left.val)
        return rightRotate(node);

    // Right Right
    if (balance < -1 && val > node.right.val)
        return leftRotate(node);

    // Left Right
    if (balance > 1 && val > node.left.val) {
        node.left = leftRotate(node.left);
        return rightRotate(node);
    }

    // Right Left
    if (balance < -1 && val < node.right.val) {
        node.right = rightRotate(node.right);
        return leftRotate(node);
    }

    return node;
}

function inorder(root) {
    if (!root) return;
    inorder(root.left);
    process.stdout.write(root.val + " ");
    inorder(root.right);
}

let root = null;
root = insert(root, 10);
root = insert(root, 20);
root = insert(root, 30);
root = insert(root, 40);
root = insert(root, 50);
root = insert(root, 25);

process.stdout.write("Inorder traversal of AVL tree: ");
inorder(root);
console.log();
```

**Output:**
```
Inorder traversal of AVL tree: 10 20 25 30 40 50
```
  </Tab>
</Tabs>

<TranslatedText en={<><p><strong>Time Complexity:</strong> O(log n) for all operations</p><p><strong>Space Complexity:</strong> O(n)</p></>} bn={<><p><strong>সময় জটিলতা:</strong> O(log n) সব অপারেশনের জন্য</p><p><strong>স্থান জটিলতা:</strong> O(n)</p></>} />
