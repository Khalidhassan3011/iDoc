---
title: 96. Trie Data Structure
description: Implement Trie for efficient string operations
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="Trie Data Structure" bn="ট্রাই ডেটা স্ট্রাকচার" />

<TranslatedText en="Implement a Trie (Prefix Tree) with insert and search operations." bn="ইনসার্ট এবং সার্চ অপারেশন সহ একটি ট্রাই (প্রিফিক্স ট্রি) বাস্তবায়ন করুন।" />

## <TranslatedText en="Solution" bn="সমাধান" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isEndOfWord;

    TrieNode() : isEndOfWord(false) {}
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode* node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                node->children[ch] = new TrieNode();
            }
            node = node->children[ch];
        }
        node->isEndOfWord = true;
    }

    bool search(string word) {
        TrieNode* node = root;
        for (char ch : word) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return node->isEndOfWord;
    }

    bool startsWith(string prefix) {
        TrieNode* node = root;
        for (char ch : prefix) {
            if (node->children.find(ch) == node->children.end()) {
                return false;
            }
            node = node->children[ch];
        }
        return true;
    }
};

int main() {
    Trie trie;
    trie.insert("apple");
    trie.insert("app");

    cout << "Search 'apple': " << (trie.search("apple") ? "Found" : "Not Found") << endl;
    cout << "Search 'app': " << (trie.search("app") ? "Found" : "Not Found") << endl;
    cout << "Search 'appl': " << (trie.search("appl") ? "Found" : "Not Found") << endl;
    cout << "Starts with 'app': " << (trie.startsWith("app") ? "Yes" : "No") << endl;

    return 0;
}
```

**Output:**
```
Search 'apple': Found
Search 'app': Found
Search 'appl': Not Found
Starts with 'app': Yes
```
  </Tab>
  <Tab value="Python">
```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end_of_word = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                node.children[ch] = TrieNode()
            node = node.children[ch]
        node.is_end_of_word = True

    def search(self, word):
        node = self.root
        for ch in word:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return node.is_end_of_word

    def starts_with(self, prefix):
        node = self.root
        for ch in prefix:
            if ch not in node.children:
                return False
            node = node.children[ch]
        return True

trie = Trie()
trie.insert("apple")
trie.insert("app")

print("Search 'apple':", "Found" if trie.search("apple") else "Not Found")
print("Search 'app':", "Found" if trie.search("app") else "Not Found")
print("Search 'appl':", "Found" if trie.search("appl") else "Not Found")
print("Starts with 'app':", "Yes" if trie.starts_with("app") else "No")
```

**Output:**
```
Search 'apple': Found
Search 'app': Found
Search 'appl': Not Found
Starts with 'app': Yes
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class TrieNode {
    constructor() {
        this.children = {};
        this.isEndOfWord = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let node = this.root;
        for (const ch of word) {
            if (!(ch in node.children)) {
                node.children[ch] = new TrieNode();
            }
            node = node.children[ch];
        }
        node.isEndOfWord = true;
    }

    search(word) {
        let node = this.root;
        for (const ch of word) {
            if (!(ch in node.children)) {
                return false;
            }
            node = node.children[ch];
        }
        return node.isEndOfWord;
    }

    startsWith(prefix) {
        let node = this.root;
        for (const ch of prefix) {
            if (!(ch in node.children)) {
                return false;
            }
            node = node.children[ch];
        }
        return true;
    }
}

const trie = new Trie();
trie.insert("apple");
trie.insert("app");

console.log("Search 'apple':", trie.search("apple") ? "Found" : "Not Found");
console.log("Search 'app':", trie.search("app") ? "Found" : "Not Found");
console.log("Search 'appl':", trie.search("appl") ? "Found" : "Not Found");
console.log("Starts with 'app':", trie.startsWith("app") ? "Yes" : "No");
```

**Output:**
```
Search 'apple': Found
Search 'app': Found
Search 'appl': Not Found
Starts with 'app': Yes
```
  </Tab>
</Tabs>

<TranslatedText en={<><p><strong>Time Complexity:</strong> O(m) where m is key length</p><p><strong>Space Complexity:</strong> O(n × m) for n keys</p></>} bn={<><p><strong>সময় জটিলতা:</strong> O(m) যেখানে m হল কী দৈর্ঘ্য</p><p><strong>স্থান জটিলতা:</strong> O(n × m) n কীগুলির জন্য</p></>} />
