---
title: 43. Remove Duplicates Without Library
description: How to remove duplicates from an array without using any library or built-in collection methods
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { TranslatedText, LanguageSwitcher } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

## <TranslatedText en="Problem Statement" bn="সমস্যার বিবৃতি" />

<TranslatedText
  en="Write a program to remove duplicate elements from an array without using any collection API or library methods. The solution should use only basic array operations and loops."
  bn="কোনো কালেকশন API বা লাইব্রেরি মেথড ব্যবহার না করে একটি অ্যারে থেকে ডুপ্লিকেট এলিমেন্ট সরানোর জন্য একটি প্রোগ্রাম লিখুন। সমাধানে শুধুমাত্র মৌলিক অ্যারে অপারেশন এবং লুপ ব্যবহার করতে হবে।"
/>

## <TranslatedText en="Examples" bn="উদাহরণসমূহ" />

### <TranslatedText en="Example 1" bn="উদাহরণ ১" />

```
Input: [1, 2, 3, 2, 4, 1, 5]
Output: [1, 2, 3, 4, 5]
```

### <TranslatedText en="Example 2" bn="উদাহরণ ২" />

```
Input: [5, 5, 5, 3, 3, 1]
Output: [5, 3, 1]
```

### <TranslatedText en="Example 3" bn="উদাহরণ ৩" />

```
Input: [1, 2, 3, 4, 5]
Output: [1, 2, 3, 4, 5]
Explanation: No duplicates
```

## <TranslatedText en="Solution Approaches" bn="সমাধানের পদ্ধতিসমূহ" />

### <TranslatedText en="Approach 1: Using Temporary Array (Simple)" bn="পদ্ধতি ১: টেম্পোরারি অ্যারে ব্যবহার করে (সহজ)" />

<TranslatedText
  en="Create a new array and copy only unique elements. For each element, check if it already exists in the result array before adding."
  bn="একটি নতুন অ্যারে তৈরি করুন এবং শুধুমাত্র ইউনিক এলিমেন্ট কপি করুন। প্রতিটি এলিমেন্টের জন্য, যোগ করার আগে চেক করুন এটি ইতিমধ্যে রেজাল্ট অ্যারেতে বিদ্যমান কিনা।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n²)
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> removeDuplicates(const vector<int>& arr) {
    if (arr.empty()) return {};

    vector<int> result;

    for (int i = 0; i < arr.size(); i++) {
        bool isDuplicate = false;

        // Check if element already exists in result
        for (int j = 0; j < result.size(); j++) {
            if (arr[i] == result[j]) {
                isDuplicate = true;
                break;
            }
        }

        // Add to result if not duplicate
        if (!isDuplicate) {
            result.push_back(arr[i]);
        }
    }

    return result;
}

int main() {
    vector<int> arr1 = {1, 2, 3, 2, 4, 1, 5};
    cout << "Original: ";
    for (int x : arr1) cout << x << " ";

    vector<int> unique1 = removeDuplicates(arr1);
    cout << "\nWithout duplicates: ";
    for (int x : unique1) cout << x << " ";
    cout << endl;

    vector<int> arr2 = {5, 5, 5, 3, 3, 1};
    cout << "\nOriginal: ";
    for (int x : arr2) cout << x << " ";

    vector<int> unique2 = removeDuplicates(arr2);
    cout << "\nWithout duplicates: ";
    for (int x : unique2) cout << x << " ";
    cout << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def remove_duplicates(arr):
    """Remove duplicates using temporary array"""
    if not arr:
        return []

    result = []

    for i in range(len(arr)):
        is_duplicate = False

        # Check if element already exists in result
        for j in range(len(result)):
            if arr[i] == result[j]:
                is_duplicate = True
                break

        # Add to result if not duplicate
        if not is_duplicate:
            result.append(arr[i])

    return result

# Example usage
arr1 = [1, 2, 3, 2, 4, 1, 5]
print(f"Original: {arr1}")
print(f"Without duplicates: {remove_duplicates(arr1)}")

arr2 = [5, 5, 5, 3, 3, 1]
print(f"\nOriginal: {arr2}")
print(f"Without duplicates: {remove_duplicates(arr2)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function removeDuplicates(arr) {
    if (arr.length === 0) return [];

    let result = [];

    for (let i = 0; i < arr.length; i++) {
        let isDuplicate = false;

        // Check if element already exists in result
        for (let j = 0; j < result.length; j++) {
            if (arr[i] === result[j]) {
                isDuplicate = true;
                break;
            }
        }

        // Add to result if not duplicate
        if (!isDuplicate) {
            result.push(arr[i]);
        }
    }

    return result;
}

// Example usage
let arr1 = [1, 2, 3, 2, 4, 1, 5];
console.log("Original:", arr1);
console.log("Without duplicates:", removeDuplicates(arr1));

let arr2 = [5, 5, 5, 3, 3, 1];
console.log("\nOriginal:", arr2);
console.log("Without duplicates:", removeDuplicates(arr2));
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 2: Sort First Then Remove" bn="পদ্ধতি ২: প্রথমে সর্ট করুন তারপর সরান" />

<TranslatedText
  en="Sort the array first, then remove consecutive duplicates. After sorting, duplicates will be adjacent, making removal easier."
  bn="প্রথমে অ্যারে সর্ট করুন, তারপর পরপর ডুপ্লিকেট সরান। সর্ট করার পরে, ডুপ্লিকেটগুলি পাশাপাশি থাকবে, যা সরানো সহজ করে তোলে।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n log n) <TranslatedText en="for sorting + O(n) for removal" bn="সর্টিং এর জন্য + O(n) সরানোর জন্য" />
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        // Partition
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr[i], arr[j]);
            }
        }
        swap(arr[i + 1], arr[high]);
        int pivotIndex = i + 1;

        // Recursively sort
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

vector<int> removeDuplicatesSorted(vector<int> arr) {
    if (arr.empty()) return {};

    // Sort the array
    quickSort(arr, 0, arr.size() - 1);

    // Remove consecutive duplicates
    vector<int> result;
    result.push_back(arr[0]);

    for (int i = 1; i < arr.size(); i++) {
        if (arr[i] != arr[i - 1]) {
            result.push_back(arr[i]);
        }
    }

    return result;
}

int main() {
    vector<int> arr = {1, 2, 3, 2, 4, 1, 5};
    cout << "Original: ";
    for (int x : arr) cout << x << " ";

    vector<int> unique = removeDuplicatesSorted(arr);
    cout << "\nWithout duplicates: ";
    for (int x : unique) cout << x << " ";
    cout << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def quick_sort(arr, low, high):
    """Quick sort implementation"""
    if low < high:
        # Partition
        pivot = arr[high]
        i = low - 1

        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]

        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        pivot_index = i + 1

        # Recursively sort
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def remove_duplicates_sorted(arr):
    """Remove duplicates after sorting"""
    if not arr:
        return []

    # Create a copy and sort it
    sorted_arr = arr.copy()
    quick_sort(sorted_arr, 0, len(sorted_arr) - 1)

    # Remove consecutive duplicates
    result = [sorted_arr[0]]

    for i in range(1, len(sorted_arr)):
        if sorted_arr[i] != sorted_arr[i - 1]:
            result.append(sorted_arr[i])

    return result

# Example usage
arr = [1, 2, 3, 2, 4, 1, 5]
print(f"Original: {arr}")
print(f"Without duplicates: {remove_duplicates_sorted(arr)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function quickSort(arr, low, high) {
    if (low < high) {
        // Partition
        let pivot = arr[high];
        let i = low - 1;

        for (let j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }
        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
        let pivotIndex = i + 1;

        // Recursively sort
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

function removeDuplicatesSorted(arr) {
    if (arr.length === 0) return [];

    // Create a copy and sort it
    let sortedArr = [...arr];
    quickSort(sortedArr, 0, sortedArr.length - 1);

    // Remove consecutive duplicates
    let result = [sortedArr[0]];

    for (let i = 1; i < sortedArr.length; i++) {
        if (sortedArr[i] !== sortedArr[i - 1]) {
            result.push(sortedArr[i]);
        }
    }

    return result;
}

// Example usage
let arr = [1, 2, 3, 2, 4, 1, 5];
console.log("Original:", arr);
console.log("Without duplicates:", removeDuplicatesSorted(arr));
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 3: Manual Hash Table Implementation" bn="পদ্ধতি ৩: ম্যানুয়াল হ্যাশ টেবিল বাস্তবায়ন" />

<TranslatedText
  en="Implement a simple hash table from scratch without using library collections. This approach provides O(n) average time complexity."
  bn="লাইব্রেরি কালেকশন ব্যবহার না করে স্ক্র্যাচ থেকে একটি সহজ হ্যাশ টেবিল বাস্তবায়ন করুন। এই পদ্ধতি O(n) গড় সময় জটিলতা প্রদান করে।"
/>

**<TranslatedText en="Time Complexity" bn="সময় জটিলতা" />:** O(n) <TranslatedText en="average" bn="গড়" />
**<TranslatedText en="Space Complexity" bn="স্থান জটিলতা" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
using namespace std;

class SimpleHashTable {
private:
    vector<vector<int>> buckets;
    int size;

    int hash(int key) {
        return abs(key) % size;
    }

public:
    SimpleHashTable(int s) : size(s) {
        buckets.resize(size);
    }

    bool contains(int key) {
        int index = hash(key);
        for (int value : buckets[index]) {
            if (value == key) return true;
        }
        return false;
    }

    void add(int key) {
        if (!contains(key)) {
            int index = hash(key);
            buckets[index].push_back(key);
        }
    }
};

vector<int> removeDuplicatesHash(const vector<int>& arr) {
    if (arr.empty()) return {};

    SimpleHashTable hashTable(arr.size());
    vector<int> result;

    for (int i = 0; i < arr.size(); i++) {
        if (!hashTable.contains(arr[i])) {
            hashTable.add(arr[i]);
            result.push_back(arr[i]);
        }
    }

    return result;
}

int main() {
    vector<int> arr = {1, 2, 3, 2, 4, 1, 5};
    cout << "Original: ";
    for (int x : arr) cout << x << " ";

    vector<int> unique = removeDuplicatesHash(arr);
    cout << "\nWithout duplicates: ";
    for (int x : unique) cout << x << " ";
    cout << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
class SimpleHashTable:
    """Simple hash table implementation without library collections"""

    def __init__(self, size):
        self.size = size
        self.buckets = [[] for _ in range(size)]

    def _hash(self, key):
        """Hash function"""
        return abs(key) % self.size

    def contains(self, key):
        """Check if key exists"""
        index = self._hash(key)
        for value in self.buckets[index]:
            if value == key:
                return True
        return False

    def add(self, key):
        """Add key if not exists"""
        if not self.contains(key):
            index = self._hash(key)
            self.buckets[index].append(key)

def remove_duplicates_hash(arr):
    """Remove duplicates using manual hash table"""
    if not arr:
        return []

    hash_table = SimpleHashTable(len(arr))
    result = []

    for i in range(len(arr)):
        if not hash_table.contains(arr[i]):
            hash_table.add(arr[i])
            result.append(arr[i])

    return result

# Example usage
arr = [1, 2, 3, 2, 4, 1, 5]
print(f"Original: {arr}")
print(f"Without duplicates: {remove_duplicates_hash(arr)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class SimpleHashTable {
    constructor(size) {
        this.size = size;
        this.buckets = Array.from({ length: size }, () => []);
    }

    hash(key) {
        return Math.abs(key) % this.size;
    }

    contains(key) {
        const index = this.hash(key);
        for (let value of this.buckets[index]) {
            if (value === key) return true;
        }
        return false;
    }

    add(key) {
        if (!this.contains(key)) {
            const index = this.hash(key);
            this.buckets[index].push(key);
        }
    }
}

function removeDuplicatesHash(arr) {
    if (arr.length === 0) return [];

    const hashTable = new SimpleHashTable(arr.length);
    let result = [];

    for (let i = 0; i < arr.length; i++) {
        if (!hashTable.contains(arr[i])) {
            hashTable.add(arr[i]);
            result.push(arr[i]);
        }
    }

    return result;
}

// Example usage
let arr = [1, 2, 3, 2, 4, 1, 5];
console.log("Original:", arr);
console.log("Without duplicates:", removeDuplicatesHash(arr));
```
  </Tab>
</Tabs>

## <TranslatedText en="Algorithm Walkthrough" bn="অ্যালগরিদম ওয়াকথ্রু" />

<TranslatedText
  en="Let's trace the **Temporary Array** approach with array `[1, 2, 3, 2, 4, 1, 5]`:"
  bn="চলুন `[1, 2, 3, 2, 4, 1, 5]` অ্যারে দিয়ে **টেম্পোরারি অ্যারে** পদ্ধতি ট্রেস করি:"
/>

```
Input: [1, 2, 3, 2, 4, 1, 5]

Step 1: Check 1
  result = []
  1 not in result → add it
  result = [1]

Step 2: Check 2
  result = [1]
  2 not in result → add it
  result = [1, 2]

Step 3: Check 3
  result = [1, 2]
  3 not in result → add it
  result = [1, 2, 3]

Step 4: Check 2
  result = [1, 2, 3]
  2 already in result → skip
  result = [1, 2, 3]

Step 5: Check 4
  result = [1, 2, 3]
  4 not in result → add it
  result = [1, 2, 3, 4]

Step 6: Check 1
  result = [1, 2, 3, 4]
  1 already in result → skip
  result = [1, 2, 3, 4]

Step 7: Check 5
  result = [1, 2, 3, 4]
  5 not in result → add it
  result = [1, 2, 3, 4, 5]

Final Result: [1, 2, 3, 4, 5]
```

### <TranslatedText en="Sort First Visualization" bn="প্রথমে সর্ট ভিজুয়ালাইজেশন" />

```
Original: [1, 2, 3, 2, 4, 1, 5]
↓
After Sorting: [1, 1, 2, 2, 3, 4, 5]
↓
Remove Consecutive Duplicates:
  Keep: 1 (first occurrence)
  Skip: 1 (duplicate)
  Keep: 2 (first occurrence)
  Skip: 2 (duplicate)
  Keep: 3, 4, 5 (no duplicates)
↓
Result: [1, 2, 3, 4, 5]
```

## <TranslatedText en="Comparison of Approaches" bn="পদ্ধতিসমূহের তুলনা" />

| <TranslatedText en="Approach" bn="পদ্ধতি" /> | <TranslatedText en="Time" bn="সময়" /> | <TranslatedText en="Space" bn="স্থান" /> | <TranslatedText en="Pros" bn="সুবিধা" /> | <TranslatedText en="Cons" bn="অসুবিধা" /> |
|----------|------|-------|------|------|
| Temporary Array | O(n²) | O(n) | <TranslatedText en="Simple, preserves order" bn="সহজ, ক্রম সংরক্ষণ করে" /> | <TranslatedText en="Slow for large arrays" bn="বড় অ্যারের জন্য ধীর" /> |
| Sort First | O(n log n) | O(n) | <TranslatedText en="Faster than nested loops" bn="নেস্টেড লুপের চেয়ে দ্রুত" /> | <TranslatedText en="Changes order" bn="ক্রম পরিবর্তন করে" /> |
| Manual Hash | O(n) | O(n) | <TranslatedText en="Fast, preserves order" bn="দ্রুত, ক্রম সংরক্ষণ করে" /> | <TranslatedText en="Complex implementation" bn="জটিল বাস্তবায়ন" /> |

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

### 1. <TranslatedText en="No Library Collections" bn="কোনো লাইব্রেরি কালেকশন নেই" />

<TranslatedText
  en="The challenge is to avoid using Set, Map, or other high-level collections. We must implement duplicate detection manually using basic arrays and loops."
  bn="চ্যালেঞ্জ হল Set, Map বা অন্যান্য উচ্চ-স্তরের কালেকশন ব্যবহার এড়ানো। আমাদের মৌলিক অ্যারে এবং লুপ ব্যবহার করে ম্যানুয়ালি ডুপ্লিকেট সনাক্তকরণ বাস্তবায়ন করতে হবে।"
/>

### 2. <TranslatedText en="Order Preservation" bn="ক্রম সংরক্ষণ" />

<TranslatedText
  en="The **Temporary Array** and **Hash Table** approaches preserve the original insertion order. The **Sort First** approach does not preserve order but is faster."
  bn="**টেম্পোরারি অ্যারে** এবং **হ্যাশ টেবিল** পদ্ধতি মূল ইনসার্শন অর্ডার সংরক্ষণ করে। **প্রথমে সর্ট** পদ্ধতি অর্ডার সংরক্ষণ করে না কিন্তু দ্রুততর।"
/>

### 3. <TranslatedText en="Time-Space Tradeoff" bn="সময়-স্থান ট্রেডঅফ" />

<TranslatedText
  en="Faster solutions (hash table) use more space. Simpler solutions (temporary array with nested loop) are slower but easier to understand."
  bn="দ্রুততর সমাধান (হ্যাশ টেবিল) আরো স্পেস ব্যবহার করে। সহজ সমাধান (নেস্টেড লুপ সহ টেম্পোরারি অ্যারে) ধীর কিন্তু বোঝা সহজ।"
/>

### 4. <TranslatedText en="Hash Table Concept" bn="হ্যাশ টেবিল ধারণা" />

<TranslatedText
  en="The manual hash table uses **buckets** (arrays) and a **hash function** (modulo) to achieve O(1) average lookup time. This mimics what Set/Map do internally."
  bn="ম্যানুয়াল হ্যাশ টেবিল **বাকেট** (অ্যারে) এবং একটি **হ্যাশ ফাংশন** (মডিউলো) ব্যবহার করে O(1) গড় লুকআপ সময় অর্জন করে। এটি Set/Map অভ্যন্তরীণভাবে যা করে তার অনুকরণ করে।"
/>

## <TranslatedText en="Interview Tips" bn="ইন্টারভিউ টিপস" />

<TranslatedText
  en="1. **Clarify Constraints**: Ask if you can use library collections or must implement from scratch"
  bn="১. **সীমাবদ্ধতা স্পষ্ট করুন**: জিজ্ঞাসা করুন আপনি লাইব্রেরি কালেকশন ব্যবহার করতে পারবেন নাকি স্ক্র্যাচ থেকে বাস্তবায়ন করতে হবে"
/>

<TranslatedText
  en="2. **Order Matters**: Ask if the original order must be preserved"
  bn="২. **অর্ডার গুরুত্বপূর্ণ**: জিজ্ঞাসা করুন মূল অর্ডার সংরক্ষণ করতে হবে কিনা"
/>

<TranslatedText
  en="3. **Start Simple**: Begin with the temporary array approach, then optimize if needed"
  bn="৩. **সহজ দিয়ে শুরু করুন**: টেম্পোরারি অ্যারে পদ্ধতি দিয়ে শুরু করুন, তারপর প্রয়োজনে অপটিমাইজ করুন"
/>

<TranslatedText
  en="4. **Discuss Tradeoffs**: Explain time vs space complexity for each approach"
  bn="৪. **ট্রেডঅফ আলোচনা করুন**: প্রতিটি পদ্ধতির জন্য সময় বনাম স্পেস কমপ্লেক্সিটি ব্যাখ্যা করুন"
/>

<TranslatedText
  en="5. **Edge Cases**: Handle empty arrays, single elements, all duplicates"
  bn="৫. **এজ কেস**: খালি অ্যারে, একক এলিমেন্ট, সব ডুপ্লিকেট হ্যান্ডেল করুন"
/>

## <TranslatedText en="Edge Cases" bn="এজ কেস" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
void testEdgeCases() {
    // Empty array
    vector<int> empty = {};
    cout << "Empty: ";
    auto r1 = removeDuplicates(empty);
    for (int x : r1) cout << x << " ";
    cout << endl;

    // Single element
    vector<int> single = {1};
    cout << "Single: ";
    auto r2 = removeDuplicates(single);
    for (int x : r2) cout << x << " ";
    cout << endl;

    // All duplicates
    vector<int> allDup = {1, 1, 1, 1};
    cout << "All duplicates: ";
    auto r3 = removeDuplicates(allDup);
    for (int x : r3) cout << x << " ";
    cout << endl;

    // No duplicates
    vector<int> noDup = {1, 2, 3, 4, 5};
    cout << "No duplicates: ";
    auto r4 = removeDuplicates(noDup);
    for (int x : r4) cout << x << " ";
    cout << endl;

    // Negative numbers
    vector<int> negative = {-1, -2, -1, 0, -2};
    cout << "Negative numbers: ";
    auto r5 = removeDuplicates(negative);
    for (int x : r5) cout << x << " ";
    cout << endl;
}
```
  </Tab>
  <Tab value="Python">
```python
def test_edge_cases():
    # Empty array
    empty = []
    print(f"Empty: {remove_duplicates(empty)}")

    # Single element
    single = [1]
    print(f"Single: {remove_duplicates(single)}")

    # All duplicates
    all_dup = [1, 1, 1, 1]
    print(f"All duplicates: {remove_duplicates(all_dup)}")

    # No duplicates
    no_dup = [1, 2, 3, 4, 5]
    print(f"No duplicates: {remove_duplicates(no_dup)}")

    # Negative numbers
    negative = [-1, -2, -1, 0, -2]
    print(f"Negative numbers: {remove_duplicates(negative)}")

test_edge_cases()
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function testEdgeCases() {
    // Empty array
    let empty = [];
    console.log("Empty:", removeDuplicates(empty));

    // Single element
    let single = [1];
    console.log("Single:", removeDuplicates(single));

    // All duplicates
    let allDup = [1, 1, 1, 1];
    console.log("All duplicates:", removeDuplicates(allDup));

    // No duplicates
    let noDup = [1, 2, 3, 4, 5];
    console.log("No duplicates:", removeDuplicates(noDup));

    // Negative numbers
    let negative = [-1, -2, -1, 0, -2];
    console.log("Negative numbers:", removeDuplicates(negative));
}

testEdgeCases();
```
  </Tab>
</Tabs>

## <TranslatedText en="Key Takeaways" bn="মূল শিক্ষা" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>No Library Constraint:</strong> Must implement duplicate detection using only basic arrays and loops</li>
        <li><strong>Three Main Approaches:</strong> Temporary array (O(n²)), Sort first (O(n log n)), Hash table (O(n))</li>
        <li><strong>Order Preservation:</strong> Temporary array and hash table preserve order, sorting does not</li>
        <li><strong>Hash Table Power:</strong> Manual hash table implementation shows how Set/Map work internally</li>
        <li><strong>Practical Skill:</strong> Understanding low-level implementations builds stronger problem-solving abilities</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>কোনো লাইব্রেরি সীমাবদ্ধতা:</strong> শুধুমাত্র মৌলিক অ্যারে এবং লুপ ব্যবহার করে ডুপ্লিকেট সনাক্তকরণ বাস্তবায়ন করতে হবে</li>
        <li><strong>তিনটি প্রধান পদ্ধতি:</strong> টেম্পোরারি অ্যারে (O(n²)), প্রথমে সর্ট (O(n log n)), হ্যাশ টেবিল (O(n))</li>
        <li><strong>অর্ডার সংরক্ষণ:</strong> টেম্পোরারি অ্যারে এবং হ্যাশ টেবিল অর্ডার সংরক্ষণ করে, সর্টিং করে না</li>
        <li><strong>হ্যাশ টেবিল শক্তি:</strong> ম্যানুয়াল হ্যাশ টেবিল বাস্তবায়ন দেখায় Set/Map অভ্যন্তরীণভাবে কীভাবে কাজ করে</li>
        <li><strong>ব্যবহারিক দক্ষতা:</strong> নিম্ন-স্তরের বাস্তবায়ন বোঝা শক্তিশালী সমস্যা সমাধান ক্ষমতা তৈরি করে</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Common Pitfalls" bn="সাধারণ সমস্যা" />

<TranslatedText
  en="- Not handling empty arrays"
  bn="- খালি অ্যারে হ্যান্ডেল না করা"
/>

<TranslatedText
  en="- Assuming elements are in a specific range (for boolean array approach)"
  bn="- এলিমেন্ট একটি নির্দিষ্ট রেঞ্জে আছে ধরে নেওয়া (বুলিয়ান অ্যারে পদ্ধতির জন্য)"
/>

<TranslatedText
  en="- Modifying original array unintentionally"
  bn="- অনিচ্ছাকৃতভাবে অরিজিনাল অ্যারে পরিবর্তন করা"
/>

<TranslatedText
  en="- Not preserving insertion order when required"
  bn="- প্রয়োজনীয় হলে ইনসার্শন অর্ডার সংরক্ষণ না করা"
/>

<TranslatedText
  en="- Integer overflow in hash function"
  bn="- হ্যাশ ফাংশনে ইন্টিজার ওভারফ্লো"
/>

## <TranslatedText en="Reference" bn="রেফারেন্স" />

[JavaRevisited - Remove Duplicates Without Collection API](http://javarevisited.blogspot.sg/2014/01/how-to-remove-duplicates-from-array-java-without-collection-API.html)
