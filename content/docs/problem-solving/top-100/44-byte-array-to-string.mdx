---
title: 44. Convert Byte Array to String
description: How to convert a byte array to a String in different ways
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { TranslatedText, LanguageSwitcher } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

## <TranslatedText en="Problem Statement" bn="‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶¨‡¶ø‡¶¨‡ßÉ‡¶§‡¶ø" />

<TranslatedText
  en="Write a program to convert a byte array to a String. Learn different approaches including using encoding, decoding, and various character sets."
  bn="‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßá ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç-‡¶è ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§ ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç, ‡¶°‡¶ø‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∏‡ßá‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶∏‡¶π ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶∂‡¶ø‡¶ñ‡ßÅ‡¶®‡•§"
/>

## <TranslatedText en="Examples" bn="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡¶∏‡¶Æ‡ßÇ‡¶π" />

### <TranslatedText en="Example 1: ASCII" bn="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ßß: ASCII" />

```
Input: [72, 101, 108, 108, 111]
Output: "Hello"
```

### <TranslatedText en="Example 2: UTF-8" bn="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ß®: UTF-8" />

```
Input: [68, 97, 114, 116]
Output: "Dart"
```

### <TranslatedText en="Example 3: Special Characters" bn="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£ ‡ß©: ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞" />

```
Input: [240, 159, 152, 128]  // UTF-8 bytes for üòÄ
Output: "üòÄ"
```

## <TranslatedText en="Solution Approaches" bn="‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶®‡ßá‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡¶∏‡¶Æ‡ßÇ‡¶π" />

### <TranslatedText en="Approach 1: Direct Byte to Character Conversion (Simple)" bn="‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ßß: ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü ‡¶•‡ßá‡¶ï‡ßá ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ (‡¶∏‡¶π‡¶ú)" />

<TranslatedText
  en="The simplest way to convert a list of bytes to a string using built-in functions. Works well for ASCII characters."
  bn="‡¶¨‡¶ø‡¶≤‡ßç‡¶ü-‡¶á‡¶® ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá ‡¶¨‡¶æ‡¶á‡¶ü‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶Ç-‡¶è ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶∏‡¶π‡¶ú ‡¶â‡¶™‡¶æ‡¶Ø‡¶º‡•§ ASCII ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§"
/>

**<TranslatedText en="Time Complexity" bn="‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)
**<TranslatedText en="Space Complexity" bn="‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

string byteArrayToString(const vector<int>& bytes) {
    string result;
    for (int byte : bytes) {
        result += static_cast<char>(byte);
    }
    return result;
}

int main() {
    // ASCII characters
    vector<int> bytes1 = {72, 101, 108, 108, 111}; // "Hello"
    cout << "Bytes: ";
    for (int b : bytes1) cout << b << " ";
    cout << "\nString: " << byteArrayToString(bytes1) << endl;

    // Another example
    vector<int> bytes2 = {68, 97, 114, 116}; // "Dart"
    cout << "\nBytes: ";
    for (int b : bytes2) cout << b << " ";
    cout << "\nString: " << byteArrayToString(bytes2) << endl;

    // Numbers and symbols
    vector<int> bytes3 = {49, 50, 51, 33}; // "123!"
    cout << "\nBytes: ";
    for (int b : bytes3) cout << b << " ";
    cout << "\nString: " << byteArrayToString(bytes3) << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def byte_array_to_string(bytes_list):
    """Convert byte array to string"""
    return ''.join(chr(byte) for byte in bytes_list)

# Example usage
# ASCII characters
bytes1 = [72, 101, 108, 108, 111]  # "Hello"
print(f"Bytes: {bytes1}")
print(f"String: {byte_array_to_string(bytes1)}")

# Another example
bytes2 = [68, 97, 114, 116]  # "Dart"
print(f"\nBytes: {bytes2}")
print(f"String: {byte_array_to_string(bytes2)}")

# Numbers and symbols
bytes3 = [49, 50, 51, 33]  # "123!"
print(f"\nBytes: {bytes3}")
print(f"String: {byte_array_to_string(bytes3)}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function byteArrayToString(bytes) {
    return bytes.map(byte => String.fromCharCode(byte)).join('');
}

// Example usage
// ASCII characters
let bytes1 = [72, 101, 108, 108, 111]; // "Hello"
console.log("Bytes:", bytes1);
console.log("String:", byteArrayToString(bytes1));

// Another example
let bytes2 = [68, 97, 114, 116]; // "Dart"
console.log("\nBytes:", bytes2);
console.log("String:", byteArrayToString(bytes2));

// Numbers and symbols
let bytes3 = [49, 50, 51, 33]; // "123!"
console.log("\nBytes:", bytes3);
console.log("String:", byteArrayToString(bytes3));
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 2: UTF-8 Decoder (Proper Encoding)" bn="‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ß®: UTF-8 ‡¶°‡¶ø‡¶ï‡ßã‡¶°‡¶æ‡¶∞ (‡¶∏‡¶†‡¶ø‡¶ï ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç)" />

<TranslatedText
  en="Properly decode UTF-8 encoded bytes. This is important for multi-byte characters like emojis and international text."
  bn="UTF-8 ‡¶è‡¶®‡¶ï‡ßã‡¶°‡ßá‡¶° ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶°‡¶ø‡¶ï‡ßã‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶ú‡¶æ‡¶§‡¶ø‡¶ï ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶æ‡¶á‡¶ü ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶è‡¶ü‡¶ø ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£‡•§"
/>

**<TranslatedText en="Time Complexity" bn="‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)
**<TranslatedText en="Space Complexity" bn="‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <codecvt>
#include <locale>
using namespace std;

string byteArrayToStringUTF8(const vector<unsigned char>& bytes) {
    return string(bytes.begin(), bytes.end());
}

int main() {
    // Simple ASCII
    vector<unsigned char> bytes1 = {72, 101, 108, 108, 111};
    cout << "UTF-8 decode: " << byteArrayToStringUTF8(bytes1) << endl;

    // Multi-byte UTF-8 character (emoji)
    vector<unsigned char> bytes2 = {240, 159, 152, 128}; // üòÄ
    cout << "UTF-8 emoji: " << byteArrayToStringUTF8(bytes2) << endl;

    // Accented characters
    vector<unsigned char> bytes3 = {195, 169}; // √©
    cout << "UTF-8 accented: " << byteArrayToStringUTF8(bytes3) << endl;

    // Mixed content demonstration
    string original = "Hello World!";
    vector<unsigned char> encoded(original.begin(), original.end());
    string decoded = byteArrayToStringUTF8(encoded);

    cout << "\nOriginal: " << original << endl;
    cout << "Encoded bytes: ";
    for (auto b : encoded) cout << (int)b << " ";
    cout << "\nDecoded: " << decoded << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def byte_array_to_string_utf8(bytes_list):
    """Decode UTF-8 encoded bytes"""
    return bytes(bytes_list).decode('utf-8')

# Example usage
# Simple ASCII
bytes1 = [72, 101, 108, 108, 111]
print(f"UTF-8 decode: {byte_array_to_string_utf8(bytes1)}")

# Multi-byte UTF-8 character (emoji)
bytes2 = [240, 159, 152, 128]  # üòÄ
print(f"UTF-8 emoji: {byte_array_to_string_utf8(bytes2)}")

# Accented characters
bytes3 = [195, 169]  # √©
print(f"UTF-8 accented: {byte_array_to_string_utf8(bytes3)}")

# Mixed content
original = "Hello üëã World!"
encoded = list(original.encode('utf-8'))
decoded = byte_array_to_string_utf8(encoded)
print(f"\nOriginal: {original}")
print(f"Encoded bytes: {encoded}")
print(f"Decoded: {decoded}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function byteArrayToStringUTF8(bytes) {
    // Create a Uint8Array from bytes
    const uint8Array = new Uint8Array(bytes);
    // Use TextDecoder for proper UTF-8 decoding
    const decoder = new TextDecoder('utf-8');
    return decoder.decode(uint8Array);
}

// Example usage
// Simple ASCII
let bytes1 = [72, 101, 108, 108, 111];
console.log("UTF-8 decode:", byteArrayToStringUTF8(bytes1));

// Multi-byte UTF-8 character (emoji)
let bytes2 = [240, 159, 152, 128]; // üòÄ
console.log("UTF-8 emoji:", byteArrayToStringUTF8(bytes2));

// Accented characters
let bytes3 = [195, 169]; // √©
console.log("UTF-8 accented:", byteArrayToStringUTF8(bytes3));

// Mixed content
let original = "Hello üëã World!";
let encoder = new TextEncoder();
let encoded = Array.from(encoder.encode(original));
let decoded = byteArrayToStringUTF8(encoded);
console.log("\nOriginal:", original);
console.log("Encoded bytes:", encoded);
console.log("Decoded:", decoded);
```
  </Tab>
</Tabs>

### <TranslatedText en="Approach 3: Error Handling for Invalid Bytes" bn="‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡ß©: ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç" />

<TranslatedText
  en="Gracefully handle invalid byte sequences with fallback strategies. This is important when dealing with untrusted or corrupted data."
  bn="‡¶´‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡ßå‡¶∂‡¶≤ ‡¶∏‡¶π ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ö‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡¶∏‡ßç‡¶§ ‡¶¨‡¶æ ‡¶¶‡ßÇ‡¶∑‡¶ø‡¶§ ‡¶°‡ßá‡¶ü‡¶æ ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶è‡¶ü‡¶ø ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£‡•§"
/>

**<TranslatedText en="Time Complexity" bn="‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)
**<TranslatedText en="Space Complexity" bn="‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶ú‡¶ü‡¶ø‡¶≤‡¶§‡¶æ" />:** O(n)

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

string byteArrayToStringWithErrorHandling(const vector<unsigned char>& bytes) {
    string result;
    for (unsigned char byte : bytes) {
        // Replace invalid high bytes with replacement character
        if (byte < 128) {
            result += static_cast<char>(byte);
        } else {
            result += '?'; // Replacement character for invalid bytes
        }
    }
    return result;
}

string byteArrayToStringLatin1(const vector<unsigned char>& bytes) {
    // Latin1 accepts all byte values (0-255)
    return string(bytes.begin(), bytes.end());
}

int main() {
    // Valid ASCII
    vector<unsigned char> validBytes = {72, 101, 108, 108, 111};
    cout << "Valid ASCII: "
         << byteArrayToStringWithErrorHandling(validBytes) << endl;

    // Invalid UTF-8 sequence
    vector<unsigned char> invalidBytes = {72, 255, 255, 108, 111};
    cout << "Invalid UTF-8 (with error handling): "
         << byteArrayToStringWithErrorHandling(invalidBytes) << endl;

    // Using Latin1 which accepts all bytes
    cout << "Using Latin1 fallback: "
         << byteArrayToStringLatin1(invalidBytes) << endl;

    return 0;
}
```
  </Tab>
  <Tab value="Python">
```python
def byte_array_to_string_with_error_handling(bytes_list):
    """Handle invalid byte sequences gracefully"""
    try:
        # Try UTF-8 decode first
        return bytes(bytes_list).decode('utf-8')
    except UnicodeDecodeError:
        # Fallback to Latin1 which accepts all byte values
        return bytes(bytes_list).decode('latin-1')

def byte_array_to_string_replace_errors(bytes_list):
    """Replace invalid bytes with replacement character"""
    return bytes(bytes_list).decode('utf-8', errors='replace')

# Example usage
# Valid UTF-8
valid_bytes = [72, 101, 108, 108, 111]
print(f"Valid UTF-8: {byte_array_to_string_with_error_handling(valid_bytes)}")

# Invalid UTF-8 sequence
invalid_bytes = [72, 255, 255, 108, 111]
print(f"Invalid UTF-8 (with error handling): "
      f"{byte_array_to_string_with_error_handling(invalid_bytes)}")

# Using replace errors
print(f"With replace errors: "
      f"{byte_array_to_string_replace_errors(invalid_bytes)}")

# Using ignore errors
ignored = bytes(invalid_bytes).decode('utf-8', errors='ignore')
print(f"With ignore errors: {ignored}")
```
  </Tab>
  <Tab value="JavaScript">
```javascript
function byteArrayToStringWithErrorHandling(bytes) {
    const uint8Array = new Uint8Array(bytes);
    const decoder = new TextDecoder('utf-8', { fatal: false });
    // fatal: false means replace invalid sequences with ÔøΩ
    return decoder.decode(uint8Array);
}

function byteArrayToStringLatin1(bytes) {
    // Latin1 fallback - accepts all byte values
    return bytes.map(b => String.fromCharCode(b)).join('');
}

function safeByteArrayToString(bytes) {
    try {
        // Try UTF-8 first
        const decoder = new TextDecoder('utf-8', { fatal: true });
        return decoder.decode(new Uint8Array(bytes));
    } catch (e) {
        // Fallback to Latin1
        console.log("UTF-8 decode failed, using Latin1 fallback");
        return byteArrayToStringLatin1(bytes);
    }
}

// Example usage
// Valid UTF-8
let validBytes = [72, 101, 108, 108, 111];
console.log("Valid UTF-8:",
    byteArrayToStringWithErrorHandling(validBytes));

// Invalid UTF-8 sequence
let invalidBytes = [72, 255, 255, 108, 111];
console.log("Invalid UTF-8 (with error handling):",
    byteArrayToStringWithErrorHandling(invalidBytes));

// Using safe conversion with fallback
console.log("Safe conversion:",
    safeByteArrayToString(invalidBytes));
```
  </Tab>
</Tabs>

## <TranslatedText en="Algorithm Walkthrough" bn="‡¶Ö‡ßç‡¶Ø‡¶æ‡¶≤‡¶ó‡¶∞‡¶ø‡¶¶‡¶Æ ‡¶ì‡¶Ø‡¶º‡¶æ‡¶ï‡¶•‡ßç‡¶∞‡ßÅ" />

<TranslatedText
  en="Let's trace the conversion of byte array [72, 101, 108, 108, 111] to 'Hello':"
  bn="‡¶ö‡¶≤‡ßÅ‡¶® ‡¶¨‡¶æ‡¶á‡¶ü ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶∞‡ßá [72, 101, 108, 108, 111] ‡¶•‡ßá‡¶ï‡ßá 'Hello' ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶ü‡ßç‡¶∞‡ßá‡¶∏ ‡¶ï‡¶∞‡¶ø:"
/>

```
Input Bytes: [72, 101, 108, 108, 111]

Step 1: Byte 72
  ASCII value: 72
  Character: 'H'
  Result: "H"

Step 2: Byte 101
  ASCII value: 101
  Character: 'e'
  Result: "He"

Step 3: Byte 108
  ASCII value: 108
  Character: 'l'
  Result: "Hel"

Step 4: Byte 108
  ASCII value: 108
  Character: 'l'
  Result: "Hell"

Step 5: Byte 111
  ASCII value: 111
  Character: 'o'
  Result: "Hello"

Final String: "Hello"
```

### <TranslatedText en="UTF-8 Multi-Byte Example" bn="UTF-8 ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶æ‡¶á‡¶ü ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£" />

```
Emoji: üòÄ
UTF-8 Bytes: [240, 159, 152, 128]

Why 4 bytes?
  UTF-8 uses 1-4 bytes per character
  Basic ASCII: 1 byte (0-127)
  Emojis: 4 bytes

Byte breakdown for üòÄ:
  11110000 (240) - First byte marker
  10011111 (159) - Continuation byte
  10011000 (152) - Continuation byte
  10000000 (128) - Continuation byte

These 4 bytes together represent one emoji character!
```

## <TranslatedText en="Character Encoding Basics" bn="‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶¨‡ßá‡¶∏‡¶ø‡¶ï" />

### <TranslatedText en="ASCII (0-127)" bn="ASCII (‡ß¶-‡ßß‡ß®‡ß≠)" />

<TranslatedText
  en="- Single byte per character"
  bn="- ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü"
/>

<TranslatedText
  en="- English letters, numbers, symbols"
  bn="- ‡¶á‡¶Ç‡¶∞‡ßá‡¶ú‡¶ø ‡¶Ö‡¶ï‡ßç‡¶∑‡¶∞, ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ, ‡¶™‡ßç‡¶∞‡¶§‡ßÄ‡¶ï"
/>

<TranslatedText
  en="- Limited to 128 characters"
  bn="- ‡ßß‡ß®‡ßÆ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá ‡¶∏‡ßÄ‡¶Æ‡¶æ‡¶¨‡¶¶‡ßç‡¶ß"
/>

### <TranslatedText en="UTF-8" bn="UTF-8" />

<TranslatedText
  en="- Variable length (1-4 bytes)"
  bn="- ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡¶∂‡ßÄ‡¶≤ ‡¶¶‡ßà‡¶∞‡ßç‡¶ò‡ßç‡¶Ø (‡ßß-‡ß™ ‡¶¨‡¶æ‡¶á‡¶ü)"
/>

<TranslatedText
  en="- Backward compatible with ASCII"
  bn="- ASCII ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶™‡¶ø‡¶õ‡¶®‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶∏‡¶æ‡¶Æ‡¶û‡ßç‡¶ú‡¶∏‡ßç‡¶Ø‡¶™‡ßÇ‡¶∞‡ßç‡¶£"
/>

<TranslatedText
  en="- Supports all Unicode characters"
  bn="- ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶á‡¶â‡¶®‡¶ø‡¶ï‡ßã‡¶° ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶® ‡¶ï‡¶∞‡ßá"
/>

<TranslatedText
  en="- Most common encoding on web"
  bn="- ‡¶ì‡¶Ø‡¶º‡ßá‡¶¨‡ßá ‡¶∏‡¶¨‡¶ö‡ßá‡¶Ø‡¶º‡ßá ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç"
/>

### <TranslatedText en="Latin1 (ISO-8859-1)" bn="Latin1 (ISO-8859-1)" />

<TranslatedText
  en="- Single byte (0-255)"
  bn="- ‡¶è‡¶ï‡¶ï ‡¶¨‡¶æ‡¶á‡¶ü (‡ß¶-‡ß®‡ß´‡ß´)"
/>

<TranslatedText
  en="- Western European languages"
  bn="- ‡¶™‡¶∂‡ßç‡¶ö‡¶ø‡¶Æ ‡¶á‡¶â‡¶∞‡ßã‡¶™‡ßÄ‡¶Ø‡¶º ‡¶≠‡¶æ‡¶∑‡¶æ"
/>

<TranslatedText
  en="- Each byte is a valid character"
  bn="- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡ßà‡¶ß ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞"
/>

## <TranslatedText en="Comparison of Approaches" bn="‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø‡¶∏‡¶Æ‡ßÇ‡¶π‡ßá‡¶∞ ‡¶§‡ßÅ‡¶≤‡¶®‡¶æ" />

| <TranslatedText en="Approach" bn="‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø" /> | <TranslatedText en="Use Case" bn="‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡ßá‡¶∏" /> | <TranslatedText en="Pros" bn="‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ" /> | <TranslatedText en="Cons" bn="‡¶Ö‡¶∏‡ßÅ‡¶¨‡¶ø‡¶ß‡¶æ" /> |
|----------|----------|------|------|
| Direct Conversion | <TranslatedText en="Simple ASCII" bn="‡¶∏‡¶π‡¶ú ASCII" /> | <TranslatedText en="Easy, fast" bn="‡¶∏‡¶π‡¶ú, ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§" /> | <TranslatedText en="No multi-byte support" bn="‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶® ‡¶®‡ßá‡¶á" /> |
| UTF-8 Decoder | <TranslatedText en="International text" bn="‡¶Ü‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶ú‡¶æ‡¶§‡¶ø‡¶ï ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü" /> | <TranslatedText en="Proper encoding, emojis" bn="‡¶∏‡¶†‡¶ø‡¶ï ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç, ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø" /> | <TranslatedText en="May fail on invalid bytes" bn="‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá" /> |
| Error Handling | <TranslatedText en="Untrusted data" bn="‡¶Ö‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡¶∏‡ßç‡¶§ ‡¶°‡ßá‡¶ü‡¶æ" /> | <TranslatedText en="Robust, safe" bn="‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ, ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶¶" /> | <TranslatedText en="May lose information" bn="‡¶§‡¶•‡ßç‡¶Ø ‡¶π‡¶æ‡¶∞‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá" /> |

## <TranslatedText en="Byte Value Reference" bn="‡¶¨‡¶æ‡¶á‡¶ü ‡¶Æ‡¶æ‡¶® ‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏" />

```
Common ASCII Values:
'A' = 65, 'Z' = 90
'a' = 97, 'z' = 122
'0' = 48, '9' = 57
' ' (space) = 32
'!' = 33, '?' = 63
'\n' (newline) = 10
```

## <TranslatedText en="Key Insights" bn="‡¶Æ‡ßÇ‡¶≤ ‡¶Ö‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶¶‡ßÉ‡¶∑‡ßç‡¶ü‡¶ø" />

### 1. <TranslatedText en="Encoding Matters" bn="‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£" />

<TranslatedText
  en="Choose the correct encoding based on your data. UTF-8 is the best choice for modern applications as it supports all Unicode characters while remaining backward compatible with ASCII."
  bn="‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶°‡ßá‡¶ü‡¶æ‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø ‡¶ï‡¶∞‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶ö‡¶Ø‡¶º‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø UTF-8 ‡¶∏‡ßá‡¶∞‡¶æ ‡¶™‡¶õ‡¶®‡ßç‡¶¶ ‡¶ï‡¶æ‡¶∞‡¶£ ‡¶è‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶á‡¶â‡¶®‡¶ø‡¶ï‡ßã‡¶° ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶® ‡¶ï‡¶∞‡ßá ‡¶è‡¶¨‡¶Ç ASCII ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶™‡¶ø‡¶õ‡¶®‡ßá‡¶∞ ‡¶¶‡¶ø‡¶ï‡ßá ‡¶∏‡¶æ‡¶Æ‡¶û‡ßç‡¶ú‡¶∏‡ßç‡¶Ø‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶•‡¶æ‡¶ï‡ßá‡•§"
/>

### 2. <TranslatedText en="One Byte ‚â† One Character" bn="‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü ‚â† ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞" />

<TranslatedText
  en="In UTF-8, a single character can be 1-4 bytes. ASCII characters use 1 byte, but emojis and many international characters use 2-4 bytes."
  bn="UTF-8-‡¶è, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶è‡¶ï‡¶ï ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡ßß-‡ß™ ‡¶¨‡¶æ‡¶á‡¶ü ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§ ASCII ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡ßß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá, ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ ‡¶á‡¶Æ‡ßã‡¶ú‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶®‡ßá‡¶ï ‡¶Ü‡¶®‡ßç‡¶§‡¶∞‡ßç‡¶ú‡¶æ‡¶§‡¶ø‡¶ï ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡ß®-‡ß™ ‡¶¨‡¶æ‡¶á‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá‡•§"
/>

### 3. <TranslatedText en="Error Handling is Critical" bn="‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç ‡¶∏‡¶Æ‡¶æ‡¶≤‡ßã‡¶ö‡¶®‡¶æ‡¶Æ‡ßÇ‡¶≤‡¶ï" />

<TranslatedText
  en="Always handle invalid byte sequences gracefully. Use fallback strategies (like Latin1) or replacement characters to avoid crashes."
  bn="‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ ‡¶∏‡ßÅ‡¶®‡ßç‡¶¶‡¶∞‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶ï‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶è‡¶°‡¶º‡¶æ‡¶§‡ßá ‡¶´‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶ï‡ßå‡¶∂‡¶≤ (‡¶Ø‡ßá‡¶Æ‡¶® Latin1) ‡¶¨‡¶æ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§"
/>

## <TranslatedText en="Interview Tips" bn="‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶≠‡¶ø‡¶â ‡¶ü‡¶ø‡¶™‡¶∏" />

<TranslatedText
  en="1. **Ask About Encoding**: Always clarify what encoding is expected (UTF-8, ASCII, etc.)"
  bn="‡ßß. **‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®**: ‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ ‡¶∏‡ßç‡¶™‡¶∑‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶ï‡ßã‡¶® ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶™‡ßç‡¶∞‡¶§‡ßç‡¶Ø‡¶æ‡¶∂‡¶ø‡¶§ (UTF-8, ASCII, ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø)"
/>

<TranslatedText
  en="2. **Discuss Error Handling**: Explain how you'll handle invalid byte sequences"
  bn="‡ß®. **‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®**: ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡¶¨‡ßá‡¶®"
/>

<TranslatedText
  en="3. **Know UTF-8 Basics**: Understand multi-byte characters and why they matter"
  bn="‡ß©. **UTF-8 ‡¶¨‡ßá‡¶∏‡¶ø‡¶ï ‡¶ú‡¶æ‡¶®‡ßÅ‡¶®**: ‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø-‡¶¨‡¶æ‡¶á‡¶ü ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶è‡¶¨‡¶Ç ‡¶ï‡ßá‡¶® ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶§‡¶æ ‡¶¨‡ßÅ‡¶ù‡ßÅ‡¶®"
/>

<TranslatedText
  en="4. **Performance Considerations**: For large data, discuss efficient conversion methods"
  bn="‡ß™. **‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏ ‡¶¨‡¶ø‡¶¨‡ßá‡¶ö‡¶®‡¶æ**: ‡¶¨‡¶°‡¶º ‡¶°‡ßá‡¶ü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø, ‡¶¶‡¶ï‡ßç‡¶∑ ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞ ‡¶™‡¶¶‡ßç‡¶ß‡¶§‡¶ø ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®"
/>

<TranslatedText
  en="5. **Real-World Use Cases**: Mention network data, file I/O, API responses"
  bn="‡ß´. **‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶ú‡¶ó‡¶§‡ßá‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡ßá‡¶∏**: ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶°‡ßá‡¶ü‡¶æ, ‡¶´‡¶æ‡¶á‡¶≤ I/O, API ‡¶∞‡ßá‡¶∏‡¶™‡¶®‡ßç‡¶∏ ‡¶â‡¶≤‡ßç‡¶≤‡ßá‡¶ñ ‡¶ï‡¶∞‡ßÅ‡¶®"
/>

## <TranslatedText en="Key Takeaways" bn="‡¶Æ‡ßÇ‡¶≤ ‡¶∂‡¶ø‡¶ï‡ßç‡¶∑‡¶æ" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>UTF-8 is Standard:</strong> Use UTF-8 for modern applications - it handles all characters correctly</li>
        <li><strong>Variable Length Encoding:</strong> UTF-8 uses 1-4 bytes per character, not always one-to-one</li>
        <li><strong>Error Handling Required:</strong> Always handle invalid byte sequences to avoid crashes</li>
        <li><strong>Encoding Mismatch:</strong> Using wrong encoding (e.g., ASCII for UTF-8 data) causes corruption</li>
        <li><strong>Practical Applications:</strong> File I/O, network communication, API data exchange</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>UTF-8 ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶æ‡¶∞‡ßç‡¶°:</strong> ‡¶Ü‡¶ß‡ßÅ‡¶®‡¶ø‡¶ï ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø UTF-8 ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® - ‡¶è‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞ ‡¶∏‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡ßá</li>
        <li><strong>‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®‡¶∂‡ßÄ‡¶≤ ‡¶¶‡ßà‡¶∞‡ßç‡¶ò‡ßç‡¶Ø ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç:</strong> UTF-8 ‡¶™‡ßç‡¶∞‡¶§‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá ‡ßß-‡ß™ ‡¶¨‡¶æ‡¶á‡¶ü ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá, ‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ ‡¶è‡¶ï-‡¶•‡ßá‡¶ï‡ßá-‡¶è‡¶ï ‡¶®‡¶Ø‡¶º</li>
        <li><strong>‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶ø‡¶Ç ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®:</strong> ‡¶ï‡ßç‡¶∞‡ßç‡¶Ø‡¶æ‡¶∂ ‡¶è‡¶°‡¶º‡¶æ‡¶§‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®</li>
        <li><strong>‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶Æ‡¶ø‡¶∏‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ö:</strong> ‡¶≠‡ßÅ‡¶≤ ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ (‡¶Ø‡ßá‡¶Æ‡¶®, UTF-8 ‡¶°‡ßá‡¶ü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ASCII) ‡¶¶‡ßÅ‡¶∞‡ßç‡¶®‡ßÄ‡¶§‡¶ø ‡¶ò‡¶ü‡¶æ‡¶Ø‡¶º</li>
        <li><strong>‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ø‡¶ï ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶≤‡¶ø‡¶ï‡ßá‡¶∂‡¶®:</strong> ‡¶´‡¶æ‡¶á‡¶≤ I/O, ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶ï‡¶Æ‡¶ø‡¶â‡¶®‡¶ø‡¶ï‡ßá‡¶∂‡¶®, API ‡¶°‡ßá‡¶ü‡¶æ ‡¶è‡¶ï‡ßç‡¶∏‡¶ö‡ßá‡¶û‡ßç‡¶ú</li>
      </ul>
    </>
  }
/>

## <TranslatedText en="Common Pitfalls" bn="‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ" />

<TranslatedText
  en="- Using wrong encoding (ASCII for non-ASCII text)"
  bn="- ‡¶≠‡ßÅ‡¶≤ ‡¶è‡¶®‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ (‡¶Ö-ASCII ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ASCII)"
/>

<TranslatedText
  en="- Not handling invalid byte sequences"
  bn="- ‡¶Ö‡¶¨‡ßà‡¶ß ‡¶¨‡¶æ‡¶á‡¶ü ‡¶∏‡¶ø‡¶ï‡ßã‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡ßá‡¶≤ ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ"
/>

<TranslatedText
  en="- Assuming one byte equals one character"
  bn="- ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶æ‡¶á‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ï‡ßç‡¶Ø‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶® ‡¶ß‡¶∞‡ßá ‡¶®‡ßá‡¶ì‡¶Ø‡¶º‡¶æ"
/>

<TranslatedText
  en="- Ignoring BOM (Byte Order Mark) in files"
  bn="- ‡¶´‡¶æ‡¶á‡¶≤‡ßá BOM (‡¶¨‡¶æ‡¶á‡¶ü ‡¶Ö‡¶∞‡ßç‡¶°‡¶æ‡¶∞ ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï) ‡¶â‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶æ"
/>

<TranslatedText
  en="- Not validating input bytes before conversion"
  bn="- ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞‡ßá‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶¨‡¶æ‡¶á‡¶ü ‡¶Ø‡¶æ‡¶ö‡¶æ‡¶á ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ"
/>

## <TranslatedText en="Reference" bn="‡¶∞‡ßá‡¶´‡¶æ‡¶∞‡ßá‡¶®‡ßç‡¶∏" />

[JavaRevisited - Convert Byte Array to String](https://javarevisited.blogspot.com/2014/08/2-examples-to-convert-byte-array-to-String-in-Java.html)
