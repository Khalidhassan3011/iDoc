---
title: 104. Difference Between BFS and DFS
description: Understand the key differences between Breadth-First Search and Depth-First Search
---

import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { LanguageSwitcher, TranslatedText } from '@/components/LanguageSwitcher';

<LanguageSwitcher />

# <TranslatedText en="BFS vs DFS" bn="BFS বনাম DFS" />

<TranslatedText
  en="Understand the key differences between Breadth-First Search (BFS) and Depth-First Search (DFS) graph traversal algorithms."
  bn="ব্রেডথ-ফার্স্ট সার্চ (BFS) এবং ডেপথ-ফার্স্ট সার্চ (DFS) গ্রাফ ট্রাভার্সাল অ্যালগরিদমের মধ্যে মূল পার্থক্য বুঝুন।"
/>

## <TranslatedText en="Comparison Table" bn="তুলনা সারণী" />

<TranslatedText
  en={
    <table>
      <thead>
        <tr>
          <th>Feature</th>
          <th>BFS (Breadth-First Search)</th>
          <th>DFS (Depth-First Search)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Data Structure</td>
          <td>Queue (FIFO)</td>
          <td>Stack (LIFO) or Recursion</td>
        </tr>
        <tr>
          <td>Traversal Order</td>
          <td>Level by level (breadth-wise)</td>
          <td>Branch by branch (depth-wise)</td>
        </tr>
        <tr>
          <td>Space Complexity</td>
          <td>O(w) where w is max width</td>
          <td>O(h) where h is max height</td>
        </tr>
        <tr>
          <td>Shortest Path</td>
          <td>Guarantees shortest path in unweighted graphs</td>
          <td>Does not guarantee shortest path</td>
        </tr>
        <tr>
          <td>Memory Usage</td>
          <td>Higher for wide graphs</td>
          <td>Lower for wide graphs</td>
        </tr>
        <tr>
          <td>Use Cases</td>
          <td>Shortest path, level-order traversal</td>
          <td>Topological sort, cycle detection, pathfinding</td>
        </tr>
        <tr>
          <td>Completeness</td>
          <td>Complete (finds solution if exists)</td>
          <td>Not complete (may get stuck in infinite depth)</td>
        </tr>
      </tbody>
    </table>
  }
  bn={
    <table>
      <thead>
        <tr>
          <th>বৈশিষ্ট্য</th>
          <th>BFS (ব্রেডথ-ফার্স্ট সার্চ)</th>
          <th>DFS (ডেপথ-ফার্স্ট সার্চ)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>ডেটা স্ট্রাকচার</td>
          <td>কিউ (FIFO)</td>
          <td>স্ট্যাক (LIFO) বা রিকার্শন</td>
        </tr>
        <tr>
          <td>ট্রাভার্সাল অর্ডার</td>
          <td>লেভেল অনুসারে (প্রস্থ-অনুযায়ী)</td>
          <td>শাখা অনুসারে (গভীরতা-অনুযায়ী)</td>
        </tr>
        <tr>
          <td>স্পেস কমপ্লেক্সিটি</td>
          <td>O(w) যেখানে w হল সর্বোচ্চ প্রস্থ</td>
          <td>O(h) যেখানে h হল সর্বোচ্চ উচ্চতা</td>
        </tr>
        <tr>
          <td>ক্ষুদ্রতম পথ</td>
          <td>ওজনহীন গ্রাফে ক্ষুদ্রতম পথ গ্যারান্টি দেয়</td>
          <td>ক্ষুদ্রতম পথ গ্যারান্টি দেয় না</td>
        </tr>
        <tr>
          <td>মেমরি ব্যবহার</td>
          <td>প্রশস্ত গ্রাফের জন্য বেশি</td>
          <td>প্রশস্ত গ্রাফের জন্য কম</td>
        </tr>
        <tr>
          <td>ব্যবহার ক্ষেত্র</td>
          <td>ক্ষুদ্রতম পথ, লেভেল-অর্ডার ট্রাভার্সাল</td>
          <td>টপোলজিক্যাল সর্ট, সাইকেল সনাক্তকরণ, পাথফাইন্ডিং</td>
        </tr>
        <tr>
          <td>সম্পূর্ণতা</td>
          <td>সম্পূর্ণ (সমাধান থাকলে খুঁজে পায়)</td>
          <td>সম্পূর্ণ নয় (অসীম গভীরতায় আটকে যেতে পারে)</td>
        </tr>
      </tbody>
    </table>
  }
/>

## <TranslatedText en="Implementation" bn="বাস্তবায়ন" />

<Tabs items={['C++', 'Python', 'JavaScript']} groupId="language">
  <Tab value="C++">
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
using namespace std;

class Graph {
    int V;
    vector<vector<int>> adj;

public:
    Graph(int vertices) : V(vertices) {
        adj.resize(V);
    }

    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }

    void BFS(int start) {
        vector<bool> visited(V, false);
        queue<int> q;

        visited[start] = true;
        q.push(start);

        cout << "BFS: ";
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << " ";

            for (int neighbor : adj[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        cout << endl;
    }

    void DFSUtil(int node, vector<bool>& visited) {
        visited[node] = true;
        cout << node << " ";

        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                DFSUtil(neighbor, visited);
            }
        }
    }

    void DFS(int start) {
        vector<bool> visited(V, false);
        cout << "DFS: ";
        DFSUtil(start, visited);
        cout << endl;
    }
};

int main() {
    Graph g(7);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 3);
    g.addEdge(1, 4);
    g.addEdge(2, 5);
    g.addEdge(2, 6);

    g.BFS(0);
    g.DFS(0);

    return 0;
}
```

**Output:**
```
BFS: 0 1 2 3 4 5 6
DFS: 0 1 3 4 2 5 6
```
  </Tab>
  <Tab value="Python">
```python
from collections import deque

class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.adj = [[] for _ in range(vertices)]

    def add_edge(self, u, v):
        self.adj[u].append(v)

    def BFS(self, start):
        visited = [False] * self.V
        queue = deque([start])
        visited[start] = True

        print("BFS:", end=" ")
        while queue:
            node = queue.popleft()
            print(node, end=" ")

            for neighbor in self.adj[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
        print()

    def DFS_util(self, node, visited):
        visited[node] = True
        print(node, end=" ")

        for neighbor in self.adj[node]:
            if not visited[neighbor]:
                self.DFS_util(neighbor, visited)

    def DFS(self, start):
        visited = [False] * self.V
        print("DFS:", end=" ")
        self.DFS_util(start, visited)
        print()

# Example
g = Graph(7)
g.add_edge(0, 1)
g.add_edge(0, 2)
g.add_edge(1, 3)
g.add_edge(1, 4)
g.add_edge(2, 5)
g.add_edge(2, 6)

g.BFS(0)
g.DFS(0)
```

**Output:**
```
BFS: 0 1 2 3 4 5 6
DFS: 0 1 3 4 2 5 6
```
  </Tab>
  <Tab value="JavaScript">
```javascript
class Graph {
    constructor(vertices) {
        this.V = vertices;
        this.adj = Array.from({ length: vertices }, () => []);
    }

    addEdge(u, v) {
        this.adj[u].push(v);
    }

    BFS(start) {
        const visited = new Array(this.V).fill(false);
        const queue = [start];
        visited[start] = true;

        process.stdout.write("BFS: ");
        while (queue.length > 0) {
            const node = queue.shift();
            process.stdout.write(node + " ");

            for (const neighbor of this.adj[node]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            }
        }
        console.log();
    }

    DFSUtil(node, visited) {
        visited[node] = true;
        process.stdout.write(node + " ");

        for (const neighbor of this.adj[node]) {
            if (!visited[neighbor]) {
                this.DFSUtil(neighbor, visited);
            }
        }
    }

    DFS(start) {
        const visited = new Array(this.V).fill(false);
        process.stdout.write("DFS: ");
        this.DFSUtil(start, visited);
        console.log();
    }
}

// Example
const g = new Graph(7);
g.addEdge(0, 1);
g.addEdge(0, 2);
g.addEdge(1, 3);
g.addEdge(1, 4);
g.addEdge(2, 5);
g.addEdge(2, 6);

g.BFS(0);
g.DFS(0);
```

**Output:**
```
BFS: 0 1 2 3 4 5 6
DFS: 0 1 3 4 2 5 6
```
  </Tab>
</Tabs>

<TranslatedText
  en={
    <>
      <p><strong>Time Complexity:</strong> O(V + E) for both BFS and DFS</p>
      <p><strong>Space Complexity:</strong> O(V) for both</p>
    </>
  }
  bn={
    <>
      <p><strong>সময় জটিলতা:</strong> O(V + E) BFS এবং DFS উভয়ের জন্য</p>
      <p><strong>স্থান জটিলতা:</strong> O(V) উভয়ের জন্য</p>
    </>
  }
/>

## <TranslatedText en="Key Insights" bn="মূল অন্তর্দৃষ্টি" />

<TranslatedText
  en={
    <>
      <ul>
        <li><strong>BFS:</strong> Explores all neighbors before going deeper, uses queue</li>
        <li><strong>DFS:</strong> Explores as deep as possible before backtracking, uses stack/recursion</li>
        <li><strong>Shortest Path:</strong> BFS finds shortest path in unweighted graphs</li>
        <li><strong>Memory:</strong> BFS uses more memory for wide graphs, DFS for deep graphs</li>
      </ul>
    </>
  }
  bn={
    <>
      <ul>
        <li><strong>BFS:</strong> গভীরে যাওয়ার আগে সব প্রতিবেশী অন্বেষণ করে, কিউ ব্যবহার করে</li>
        <li><strong>DFS:</strong> ব্যাকট্র্যাক করার আগে যতটা সম্ভব গভীরে অন্বেষণ করে, স্ট্যাক/রিকার্শন ব্যবহার করে</li>
        <li><strong>ক্ষুদ্রতম পথ:</strong> BFS ওজনহীন গ্রাফে ক্ষুদ্রতম পথ খুঁজে পায়</li>
        <li><strong>মেমরি:</strong> BFS প্রশস্ত গ্রাফের জন্য বেশি মেমরি ব্যবহার করে, DFS গভীর গ্রাফের জন্য</li>
      </ul>
    </>
  }
/>
