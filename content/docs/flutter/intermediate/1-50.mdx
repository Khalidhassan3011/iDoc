---
title: Intermediate Flutter Questions (Questions 1-50)
description: Intermediate Flutter Questions (Questions 1-50)
---

# Intermediate Flutter Questions (Questions 1-50)

> **Note:**
  **Questions 1-50 of 102**

  All questions consolidated from multiple sources with source attribution.

---

## 1. Can you describe how to implement internationalization in a Flutter app?

**ðŸ“š TURINGQUESTIONS**

Flutter provides the **Intl** package, which allows you to add support for multiple languages to your app. You can use the package to define messages in different languages, format numbers, dates, and times, and apply pluralization rules based on the language.

---

## 2. Can you explain how to use streams and futures in Flutter? Also, tell us some similarities and differences between Future and Stream?

**ðŸ“š TURINGQUESTIONS**

Streams and futures are powerful tools for handling asynchronous operations in Flutter. You can use a **stream** to listen for a series of events, such as user input or network responses, and react to them in real-time. A **future**, on the other hand, represents a value that may not be available yet and allows you to execute asynchronous code and retrieve the result when it's ready.

### Similarities between future and stream:

- Both work asynchronously
- Both have some potential value

### Differences between future and stream:

- Future has **one response** whereas a stream can have **multiple responses**
- Futures are used in HTTP calls
- A Stream is a series of futures

---

## 3. Can you explain how to use the Provider package for state management in Flutter?

**ðŸ“š TURINGQUESTIONS**

The **Provider** package is a state management library that allows you to share data between widgets efficiently. You can use the Provider package to create a data model, expose it using a provider, and then access it in your widgets using the `Provider.of` method.

```dart
// Create a model
class Counter with ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();
  }
}

// Provide it
ChangeNotifierProvider(
  create: (context) => Counter(),
  child: MyApp(),
)

// Consume it
final counter = Provider.of<Counter>(context);
```

---

## 4. Can you explain the process of creating custom widgets in Flutter?

**ðŸ“š GITHUB**

The process of creating custom widgets in Flutter involves the following steps:

1. **Extend the `StatelessWidget` or `StatefulWidget` class**: To create a custom widget, we need to extend the `StatelessWidget` or `StatefulWidget` class, depending on whether the widget is stateless or stateful.

2. **Override the `build` method**: We need to override the `build` method in our custom widget class to define its appearance. The `build` method returns a widget tree that describes the appearance of the widget. We can use built-in widgets or other custom widgets to create the widget tree.

3. **Define the widget's constructor**: We can define a constructor for the custom widget to pass any required data to the widget.

4. **Use the custom widget**: Once we have defined your custom widget, we can use it in your Flutter app just like any other widget. We can add it to the widget tree in our build method or in response to user interactions.

5. **Optionally, manage state**: If the widget is stateful, we can manage its state by using the `setState` method. This method allows us to update the appearance of the widget when its state changes.

These are the basic steps involved in creating custom widgets in Flutter. The exact process may vary depending on the specific requirements of your widget, but this general process should provide a good starting point.

---

## 5. Can you give some reasons why Flutter is better than its alternatives?

**ðŸ“š TURINGQUESTIONS**

Flutter has several advantages over its alternatives. Here are some of the main reasons why Flutter is a great choice for building mobile apps:

- Flutter offers a **hot-reload feature** that enables developers to see changes in their code instantly without having to wait for the app to recompile.
- Flutter allows you to build apps that work seamlessly on **multiple platforms**, including Android, iOS, and the web.
- Flutter offers a rich set of **customizable widgets**, allowing developers to create beautiful and responsive designs that adapt to different screen sizes and orientations.
- Flutter uses a compiled programming language, **Dart**, which is optimized for performance and runs natively on the device.

---

## 6. Can you name some popular database packages in Flutter?

**ðŸ“š TURINGQUESTIONS**

Here are two widely used packages in Flutter:

- **Firebase**: It is used to use or modify the cloud database
- **Sqflite**: It is used to modify the SQLite database

---

## 7. Can you state some difference between runApp() and main()?

**ðŸ“š TURINGQUESTIONS**

**Main()**: Main() function starts the program. You cannot write a program in Flutter without using the main() function.

**runApp()**: runApp() is used to launch the software. RunApp() allows you to return the widgets that are connected to the screen as the widget tree's root.

```dart
void main() {
  runApp(MyApp());
}
```

---

## 8. Can you tell us a way to access screen size in the future?

**ðŸ“š TURINGQUESTIONS**

You can access the screen size using the **MediaQuery** class. The MediaQuery class provides information about the current device's screen size and orientation.

```dart
final size = MediaQuery.of(context).size;
final width = size.width;
final height = size.height;
```

---

## 9. Can you tell us some differences between const and final in Flutter?

**ðŸ“š TURINGQUESTIONS**

The only difference between `const` and `final` is that the **const variables are evaluated at compile-time** and are immutable whereas **final variables are evaluated at runtime** and can only be set once.

```dart
final currentTime = DateTime.now(); // Runtime value
const pi = 3.14159; // Compile-time constant
```

---

## 10. Can you tell us some examples of App State?

**ðŸ“š TURINGQUESTIONS**

Some examples of App State include:

- Login info
- Notifications in a social networking app
- User preferences

---

## 11. Can you tell us the difference between WidgetsApp and MaterialApp?

**ðŸ“š TURINGQUESTIONS**

The main difference between **WidgetsApp** and **MaterialApp** is that the widget offers basic navigation, whereas MaterialApp is built on top of WidgetsApp.

---

## 12. Define factory constructors.

**ðŸ“š TURINGQUESTIONS**

A **factory constructor** invokes another constructor, which is allowed to return an instance of a derived class, null or an existing instance. Factory constructors are defined using the `factory` keyword.

```dart
class Logger {
  static final Map<String, Logger> _cache = {};

  factory Logger(String name) {
    return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  Logger._internal(this.name);

  final String name;
}
```

---

## 13. Define the term Cookbook.

**ðŸ“š TURINGQUESTIONS**

A **cookbook** provides specific programming solutions for some common problems experienced by developers during the development process. Each recipe can be used independently during the development process.

---

## 14. Differentiate between `Stream` and `Future` in Flutter.

**ðŸ“š GITHUB**

`Stream` and `Future` are both used for asynchronous programming in Flutter, but they serve different purposes.

`Future` is a one-time asynchronous operation that returns a single value. It represents a value that will be available in the future, either a result or an error. Futures are often used for short-lived operations that complete quickly, such as fetching data from a database or an API.

`Stream`, on the other hand, is a sequence of asynchronous events. A stream can emit multiple values over time, either in response to user interaction or based on some other event. Streams are useful for continuous or long-lived operations, such as listening to updates from a sensor, receiving messages from a chat service, or playing a video.

In summary, the main difference between `Future` and `Stream` is that `Future` represents a single value that will be available in the future, while `Stream` represents a sequence of values that are emitted over time.

---

## 15. Differentiate between setState and Provider?

**ðŸ“š TURINGQUESTIONS**

The `setState()` is used for managing the **local state**. Calling the setState() function notifies the framework about the change in the state of the object and that may affect the user interaction in the subtree.

Whereas, **provider** is a state management technique in Flutter that allows widgets to access data from a central location (i.e., a "provider"). Providers can be used to manage the application state, such as user authentication or data fetched from an API.

---

## 16. Explain async, await and Future.

**ðŸ“š GITHUB**

The `async` and `await` are keywords in Dart that enable asynchronous programming. They make it easier to write asynchronous code that is readable and easier to maintain.

`Future` is a core Dart library that represents an asynchronous operation that will complete in the future. A `Future` object is returned from an asynchronous function to represent a value that will be available at some point in the future.

In Flutter, `async` and `await` are used to perform asynchronous operations, such as making HTTP requests or reading from a database. The Future object is used to represent the result of an asynchronous operation and is often passed to await in an async function to wait for the result to be available.

```dart
Future<String> fetchData() async {
  // Asynchronous operation
  return 'Data';
}

void main() async {
  String data = await fetchData();
  print(data);
}
```

---

## 17. Explain how you will deploy a Flutter app to the Google Play/App Store?

**ðŸ“š TURINGQUESTIONS**

For deploying Flutter apps to the Google Play Store or App Store, you will need to know the guidelines suggested by each. In both cases, it's important to make sure your app meets the requirements and guidelines of the respective app store before submitting it for review. This includes things like app content, user data privacy, user interface, and more.

### Deploying to Google Play Store:

1. Create a Google Play Developer account
2. Create a signing key
3. Configure your app
4. Submit your app for review
5. Publish your app

### Deploying to App Store:

1. Create an Apple Developer account
2. Create a signing certificate and provisioning profile
3. Configure your app
4. Submit your app for review
5. Publish your app

---

## 18. Explain setState() and when to call it

**ðŸ“š LEMON**

`setState()` tells Flutter that the state of the widget has changed and the UI should be rebuilt. Use it when you want to update the visual representation of data. Call it whenever you modify state variables that affect what the widget displays.

---

## 19. Explain singleton class in flutter.

**ðŸ“š GITHUB**

A singleton class is a class that can only be instantiated once throughout the entire application. It provides a single point of access to a shared instance of an object, which can be accessed from anywhere in the application.

To create a singleton class in Flutter, we need to define a private constructor that can only be accessed within the class itself. Then, we can create a static field of the class type that holds the single instance of the class, and a static method that returns the instance. Here's an example of a singleton class in Flutter:

```dart
class MySingleton {
  static final MySingleton _singleton = MySingleton._internal();

  factory MySingleton() {
    return _singleton;
  }

  MySingleton._internal();

  void doSomething() {
    print('Singleton class is doing something');
  }
}
```

In this example, `MySingleton` is a singleton class that has a private constructor, a static field `_singleton` of the same type, and a static factory method that returns the single instance of the class. The `doSomething` method is a simple method that can be called on the instance of the class.

To use this singleton class, we can simply call the factory method to get the instance of the class, and then call the methods on the instance. Here's an example:

```dart
MySingleton singleton = MySingleton();
singleton.doSomething();
```

This will create a single instance of `MySingleton` and call the `doSomething` method on it. Since `MySingleton` is a singleton class, any subsequent calls to the `MySingleton()` constructor will simply return the existing instance of the class, rather than creating a new instance.

---

## 20. Explain Streams in Flutter?

**ðŸ“š TURINGQUESTIONS**

**Future** and **Stream** are classes in Dart that define asynchronous programming. It behaves asynchronously as it doesn't return the next event when requested. Instead, it informs when the next event will be returned when ready.

---

## 21. Explain the `mounted` property. How is it important and when to use it?

**ðŸ“š GITHUB**

The mounted property defines whether the state object, associated with it, is currently in the widget tree.

After creating a State object and before calling initState, the framework **"mounts"** the State object by associating it with a BuildContext. The State object remains mounted until the framework calls dispose, after which time the framework will never ask the State object to build again.

It is an error to call setState unless mounted is true. This property is useful when a method on your state calls setState() but it isn't clear when or how often that method will be called. You can use `if (mounted) {...` to make sure the State exists before calling setState().

---

## 22. Explain the Primary Axis and Cross Axis Alignment.

**ðŸ“š TURINGQUESTIONS**

An alignment defines how a row or a column is aligned with respect to the horizontal or vertical axis. For example, for a row its main axis is horizontal and so its cross axis will be vertical.

- **PrimaryAxisAlignment**: the rows run horizontally, and the columns run vertically.
- **CrossAxisAlignment**: the rows run vertically, and the columns run horizontally.

---

## 23. Explain what a ticker is in flutter.

**ðŸ“š GITHUB**

In Flutter, a ticker is a mechanism that helps to drive animations. It provides a continuous stream of time, essentially ticking at a fixed interval (typically the frame rate). This enables the animation framework to update the UI at a consistent rate.

A `Ticker` is often used with `AnimationController`, which is responsible for controlling the animation's progress over time. The Ticker's job is to notify the animation controller every frame so that it can update the animation's state, which in turn updates the UI.

```dart
class MyAnimatedWidget extends StatefulWidget {
  @override
  _MyAnimatedWidgetState createState() => _MyAnimatedWidgetState();
}

class _MyAnimatedWidgetState extends State<MyAnimatedWidget> with TickerProviderStateMixin {
  late Ticker _ticker;

  @override
  void initState() {
    super.initState();
    _ticker = createTicker((elapsed) {
      print('Time elapsed: $elapsed');
    });
    _ticker.start();  // Starts the ticker
  }

  @override
  void dispose() {
    _ticker.dispose(); // Clean up the ticker
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Container();
  }
}
```

---

## 24. How can you prevent a widget from rebuilding?

**ðŸ“š LEMON**

Several strategies:
- Use `const` constructors to create compile-time constants
- Use `Keys` to preserve widget identity
- Extract static widgets into separate const widgets
- Use `RepaintBoundary` to isolate rebuilds
- Implement `shouldRebuild` in custom widgets

---

## 25. How do mixins differ from interfaces in Dart?

**ðŸ“š GITHUB**

In Dart, mixins and interfaces serve different purposes:

**Mixins:** Allow a class to reuse code from multiple classes without using inheritance. Mixins are typically used to add functionality to a class. They are declared using the mixin keyword and can be applied to a class via the with keyword. A class can apply multiple mixins.

```dart
mixin Walker {
  void walk() => print("Walking");
}

class Person with Walker {
  // Person can now use the walk() method
}
```

**Interfaces:** Define a contract that a class must adhere to. In Dart, all classes implicitly act as interfaces. To implement an interface, a class uses the implements keyword. Unlike mixins, interfaces do not allow code reuseâ€”they only define method signatures that must be implemented.

```dart
class Animal {
  void eat();
}

class Dog implements Animal {
  @override
  void eat() => print("Dog eating");
}
```

**Key Differences:**
- Mixins provide code reuse; can be used with multiple classes.
- Interfaces define required methods, but no code reuse. A class can implement multiple interfaces.

---

## 26. How do you add padding or margin around a widget?

**ðŸ“š LEMON**

- Use `Padding(padding: EdgeInsets.all(16))` to add internal spacing
- Or wrap the widget in a `Container` with `margin` or `padding` properties

Both approaches allow you to add space around widgets.

---

## 27. How do you apply custom fonts in a Flutter app?

**ðŸ“š LEMON**

1. Add the font files to your assets (usually in a `fonts/` directory)
2. Declare them in `pubspec.yaml`:
```yaml
flutter:
  fonts:
    - family: CustomFont
      fonts:
        - asset: fonts/CustomFont-Regular.ttf
        - asset: fonts/CustomFont-Bold.ttf
          weight: 700
```
3. Reference them using `TextStyle`:
```dart
Text(
  'Custom Font Text',
  style: TextStyle(fontFamily: 'CustomFont'),
)
```

---

## 28. How do you create a rounded button in Flutter?

**ðŸ“š LEMON**

Use an `ElevatedButton` with a custom shape such as `RoundedRectangleBorder` with a `borderRadius` property.

```dart
ElevatedButton(
  style: ElevatedButton.styleFrom(
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(20),
    ),
  ),
  onPressed: () {},
  child: Text('Rounded Button'),
)
```

---

## 29. How do you detect a button press?

**ðŸ“š LEMON**

Set the `onPressed` callback in button widgets like `TextButton`, `ElevatedButton`, or `IconButton`:

```dart
ElevatedButton(
  onPressed: () {
    // Handle button press
  },
  child: Text('Press Me'),
)
```

---

## 30. How do you handle exceptions in Flutter, and what strategies have you used?

**ðŸ“š GITHUB**

Exceptions are errors that occur at runtime and can be handled in Flutter using `try-catch` blocks. Here's a simple example of how to handle exceptions in Flutter:

```dart
try {
  // Code that might throw an exception
} on Exception catch (e) {
  // Code that is executed when an exception is caught
  print("Caught exception: $e");
}
```

In this example, the code inside the try block is executed. If an exception is thrown, it is caught by the catch block, and the code inside the catch block is executed. You can access the details of the exception by using the e variable.

There are different strategies for handling exceptions in Flutter, including:

**Logging**: We can log the details of the exception to help with debugging and troubleshooting. We can use the print function or a logging library like logging or flutter_logging.

**Showing an error message**: We can show an error message to the user to let them know that something went wrong. For example, we might show a SnackBar with a message, or navigate to an error page.

**Retrying the operation**: If the exception was caused by a temporary error, we might want to retry the operation. For example, we might retry a network request if the first attempt failed due to a timeout.

**Handling specific exceptions**: We can handle specific exceptions by using multiple catch blocks. This allows us to handle each exception differently based on its type. For example, we might handle a SocketException differently from a `FormatException`.

Here's an example of a more advanced exception handling strategy:

```dart
try {
  // Code that might throw an exception
} on SocketException catch (e) {
  // Code that is executed when a SocketException is caught
  print("Caught SocketException: $e");
  // Retry the operation
} on FormatException catch (e) {
  // Code that is executed when a FormatException is caught
  print("Caught FormatException: $e");
  // Show an error message to the user
} catch (e) {
  // Code that is executed when any other exception is caught
  print("Caught exception: $e");
  // Log the exception for debugging purposes
}
```

---

## 31. How do you handle user input in Flutter?

**ðŸ“š GITHUB**

In Flutter, we can handle user input through various widgets such as `TextField`, `Checkbox`, `Radio`, `Slider`, `DropdownButton`, `GestureDetector`, and more.

Here is a simple process for handling user input in Flutter:

1. Determine the widget that captures the user's input, such as a `TextField` for text input or a `Checkbox` for boolean input.
2. Attach a callback function to the widget that should be called when the user interacts with it. For example, we can attach the `onChanged` callback to a `Checkbox` to be notified when the user taps the checkbox.
3. In the callback function, update the state of the application based on the user's input. For example, we can update a bool variable when the user toggles a `Checkbox`, or update a String variable when the user types into a `TextField`.
4. If the state has changed, call `setState()` to rebuild the UI with the updated state.

It's important to note that the specific process for handling user input will vary depending on the widget and the requirements of the app.

---

## 32. How do you handle user input with TextField?

**ðŸ“š LEMON**

Use a `TextEditingController` to read and manipulate input from a TextField. You can:
- Access the current text value via `controller.text`
- Listen for changes using `controller.addListener()`
- Use the `onChanged` callback for real-time updates as the user types

---

## 33. How do you implement a draggable widget in flutter?

**ðŸ“š GITHUB**

To implement a draggable widget in flutter, use the `Draggable` widget. Here's how to do it:

- Use the `Draggable` widget to wrap the element you want to make draggable.
- Pass the data you want to drag through the data property.
- Use `feedback` to specify the widget that appears while dragging and `childWhenDragging` for the widget that replaces the original widget during the drag.

```dart
Draggable<int>(
  data: 1,
  feedback: Material(
    color: Colors.transparent,
    child: Icon(Icons.access_alarm, size: 50),
  ),
  childWhenDragging: Container(),
  child: Icon(Icons.access_alarm),
)
```

In this example, when the user starts dragging the icon, it shows a smaller icon as the feedback. The original icon disappears until the drag ends.

---

## 34. How do you load an image from the internet?

**ðŸ“š LEMON**

Use `Image.network()` with the URL:

```dart
Image.network('https://example.com/image.jpg')
```

You can optionally add:
- `loadingBuilder` to show a loading indicator
- `errorBuilder` to handle loading errors

---

## 35. How do you navigate to a new screen in Flutter?

**ðŸ“š LEMON**

Use the `Navigator.push()` method with a `MaterialPageRoute` to navigate to a new screen.

```dart
Navigator.push(
  context, 
  MaterialPageRoute(builder: (_) => NewScreen())
);
```

---

## 36. How do you provide accessibility when developing flutter apps, do you at all?

**ðŸ“š GITHUB**

Yes, accessibility is a critical aspect of Flutter app development to ensure that the app is usable by everyone, including users with disabilities. In Flutter, several techniques are available to enhance accessibility:

- **Use of Semantic Widgets:** Flutter provides `Semantics` widget, which allows you to annotate elements in the UI with meaningful descriptions. This helps screen readers understand what the widget represents and provides a better experience for visually impaired users.

```dart
Semantics(
  label: 'Submit button',
  child: ElevatedButton(onPressed: () {}, child: Text('Submit')),
);
```

- **Text Accessibility:** Ensure that text content is readable by screen readers. This can be achieved by using accessible widgets like `Text` with clear, concise content and by applying the correct `semanticsLabel` for any custom widgets.

- **Color Contrast:** Ensure sufficient contrast between text and background colors to assist users with visual impairments. Tools like Flutter's accessibility library can help check for contrast issues.

- **Focus Management:** Implementing keyboard navigation and focus management is essential for users with motor disabilities. Flutter provides `FocusNode` and `FocusScope` to manage focus behavior.

- **Custom Actions for Screen Readers:** For custom interactions like gestures or animations, use the `excludeSemantics` property wisely to avoid unnecessary verbosity and ensure that screen readers only announce relevant actions.

- **Testing:** Test your app with accessibility tools like the built-in Android TalkBack or iOS VoiceOver to ensure that all elements are accessible.

By using these techniques and Flutter's built-in tools, we can create more inclusive and accessible apps.

---

## 37. How do you show a dialog in Flutter?

**ðŸ“š LEMON**

Use `showDialog()` with a widget like `AlertDialog`:

```dart
showDialog(
  context: context,
  builder: (context) => AlertDialog(
    title: Text('Dialog Title'),
    content: Text('Dialog content'),
    actions: [
      TextButton(
        onPressed: () => Navigator.pop(context),
        child: Text('OK'),
      ),
    ],
  ),
);
```

---

## 38. How do you use FutureBuilder?

**ðŸ“š LEMON**

`FutureBuilder` listens to a Future and rebuilds its child based on the connection state. It handles three main states:
- **Waiting:** While the future is loading
- **Done:** When the future completes successfully
- **Error:** If the future completes with an error

This widget is ideal for loading asynchronous data and showing appropriate UI for each state.

---

## 39. How do you use the `ValueNotifier` class in Flutter?

**ðŸ“š GITHUB**

In Flutter, the `ValueNotifier` class is a simple class that provides a way to listen for changes to a value and update the UI accordingly. It's a convenient way to manage state for a small number of widgets, and is often used in combination with the `ChangeNotifier` and `Provider` classes from the Flutter `provider` package.

To use `ValueNotifier`, first we need an instance of the class with an initial value:

```dart
final ValueNotifier<String> _myValue = ValueNotifier<String>('Initial Value');
```

To listen for changes to the value, we can use the `ValueListenableBuilder` widget. This widget takes a `ValueNotifier` and a `builder` function, and rebuilds its child whenever the value changes:

```dart
ValueListenableBuilder<String>(
  valueListenable: _myValue,
  builder: (BuildContext context, String value, Widget? child) {
    return Text(value);
  },
),
```

To update the value of a `ValueNotifier`, simply set its value property:

```dart
_myValue.value = 'New Value';
```

---

## 40. How do you validate a form in Flutter?

**ðŸ“š LEMON**

1. Wrap input fields in a `Form` widget
2. Assign a `GlobalKey<FormState>()`
3. Add `validator` functions to form fields
4. Call `formKey.currentState!.validate()` to validate all fields

```dart
final formKey = GlobalKey<FormState>();

Form(
  key: formKey,
  child: TextFormField(
    validator: (value) {
      if (value?.isEmpty ?? true) return 'Required';
      return null;
    },
  ),
)

// To validate:
if (formKey.currentState!.validate()) {
  // Form is valid
}
```

---

## 41. How to create a list with persistent headers?

**ðŸ“š GITHUB**

To create a list with persistent headers in flutter, we can use the `CustomScrollView` widget along with `SliverList` and `SliverPersistentHeader`. This allows to have headers that remain visible as the user scrolls through the list.

Here's how to do it:
- Wrap the list and header in a `CustomScrollView` to enable scrolling and custom behaviors.
- The `SliverPersistentHeader` widget allows to create a header that can remain fixed or scroll away as the user scrolls the list.
- Inside `SliverPersistentHeader`, we can define the header's appearance, and we can also control whether it stays fixed or scrolls away.

```dart
class PersistentHeaderList extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: CustomScrollView(
        slivers: <Widget>[
          SliverPersistentHeader(
            delegate: _MyPersistentHeaderDelegate(),
            pinned: true, // Makes the header sticky
          ),
          SliverList(
            delegate: SliverChildBuilderDelegate(
              (BuildContext context, int index) {
                return ListTile(title: Text('Item $index'));
              },
              childCount: 100,
            ),
          ),
        ],
      ),
    );
  }
}

class _MyPersistentHeaderDelegate extends SliverPersistentHeaderDelegate {
  @override
  double get maxExtent => 100.0;
  @override
  double get minExtent => 60.0;

  @override
  Widget build(BuildContext context, double shrinkOffset, bool overlapsContent) {
    return Container(
      color: Colors.blue,
      child: Text('Persistent Header'),
    );
  }

  @override
  bool shouldRebuild(covariant SliverPersistentHeaderDelegate oldDelegate) => false;
}
```

---

## 42. How would you implement a custom transition between screens in Flutter?

**ðŸ“š TURINGQUESTIONS**

You can use the **PageRouteBuilder** class to create custom transitions between screens. This class allows you to define custom animations, such as sliding or fading, for the page transition.

```dart
Navigator.push(
  context,
  PageRouteBuilder(
    pageBuilder: (context, animation, secondaryAnimation) => SecondPage(),
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      return FadeTransition(
        opacity: animation,
        child: child,
      );
    },
  ),
);
```

---

## 43. How would you optimize the performance of a Flutter app?

**ðŸ“š TURINGQUESTIONS**

Some techniques to optimize the performance of a Flutter app include:

- Using the `const` keyword to make widgets immutable
- Avoiding unnecessary widget rebuilds
- Using the Provider package for efficient state management
- Minimizing the number of expensive operations in the build method

So, if your app is small, you can pass your data using the constructor of the widget class, but for a larger app, this is not an easy task. Unknowingly we use inherited widgets in many places while developing the flutter app: `Theme.of(context)`, `Navigator.of(context)`, and `MediaQuery.of(context)`.

---

## 44. Is it possible to nest a Scaffold? Why or why not?

**ðŸ“š TURINGQUESTIONS**

**Yes, it is possible.** Scaffold is a widget, so you can put it anywhere you want. Scaffold provides APIs like Drawer, SnackBar, BottomNavigationBar, FloatingActionButton, etc. However, it is not necessary to nest scaffolds as they can be used on their own.

---

## 45. List the responsibilities of FlutterActivity.

**ðŸ“š TURINGQUESTIONS**

The roles of a **FlutterActivity** are:

- Configuring the appearance of the status bar
- Displaying Android launch screen
- Displaying flutter splash screen
- Choosing an execution path for the Dart app bundle
- Adding transparency, which is an optional responsibility
- Saving and restoring instance state

---

## 46. Name the different types of grid view in Flutter.

**ðŸ“š TURINGQUESTIONS**

The different types of grid views in Flutter are:

- `GridView.count()`
- `GridView.custom()`
- `GridView.builder()`
- `GridView.extent()`

---

## 47. Tell me about Flutter Provider.

**ðŸ“š TURINGQUESTIONS**

Widgets are used to build the provider. Inside the provider, one can use all the objects as if they are a part of it with the new widget subclasses it creates. Primarily, it works on the concept of **PUB-SUB** which means one provider with many subscribers.

---

## 48. What are `StatefulWidget` Lifecycle methods. Explain briefly.

**ðŸ“š GITHUB**

- **createState() method:** Whenever a StatefulWidget is created, the framework calls this method to create fresh State objects. This method must be overridden.

- **initState() method:** This method is the first method that is called while creating a StatefulWidget class. Here we allocate our resources, which means we can initialize our variable, data, and properties.

- **didChangeDependencies() method:** This method is called just after initState() method when a dependency of this State object changes. For example, if the previous build was referencing an InheritedWidget that changes, this method notifies the object to change. Generally, subclasses don't override didChangeDependencies() method because the framework calls build() methods after dependency change. But to do some expensive work, let's say some network calls, the method is preferred over doing everything on build() method itself.

- **build() method:** Every time the widget is rebuilt, the build() method is used. This can happen after calling initState(), didChangeDependencies(), or didUpdateWidget(), or after changing the state with a call to setState().

- **didUpdateWidget() method:** This method is called whenever the widget configuration changes. This method exists for triggering side-effects when one of the parameters in the StatefulWidget changes. A typical example is implicitly animated widgets.

- **setState() method:** This method notifies the framework that the internal state of this object has changed. The provided callback must be synchronous which might impact the user interface in the subtree. The framework schedules a build() for this current State object.

- **deactivate() method:** The framework calls this method when the State is removed from the tree, temporarily or permanently.

- **dispose() method:** This method is called when the State is removed from the tree, permanently. After the dispose() method is called, the State object is considered unmounted. Subclasses should override this method to release any resources retained by this object.

---

## 49. What are DevTools in Flutter?

**ðŸ“š GITHUB**

`DevTools` in Flutter are a set of powerful web-based tools for debugging and profiling Flutter applications. They provide developers with detailed information about their apps, including CPU usage, memory usage, GPU rendering, and network activity. DevTools can be used to identify performance bottlenecks, inspect the widget tree, and debug issues in real-time.

Here are some of the features of DevTools:

- **Flutter inspector**: Allows us to inspect the widget tree and inspect the layout, size, and position of each widget.
- **Timeline view**: Provides a graphical representation of the performance of the app, including CPU, memory, and GPU usage.
- **Debugger**: Enables us to set breakpoints, inspect variables, and step through our code.
- **Logging view**: Displays log messages and errors generated by the app.
- **Hot reload**: Lets us modify oour code and see the changes reflected in the app without having to restart it.

---

## 50. What are different build modes in Flutter?

**ðŸ“š GITHUB**

The Flutter tooling supports three different build modes while compiling the app. We need to choose the build mode depending upon where we are in the development cycle.

- `debug`: For development purpose, the **hot reload** feature is enabled only in the debug mode.
- `profile`: For analyzing the app performance. We use DevTools suite to profile app's performance.
- `release`: For releasing the app when everything is ready.

_To learn more, check [docs](https://docs.flutter.dev/testing/build-modes)._

---